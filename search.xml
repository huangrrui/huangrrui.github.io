<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AS运行flutter App 找不到 Cocoapods 的解决方法</title>
    <url>/2022/03/21/AS%E8%BF%90%E8%A1%8Cflutter-App-%E6%89%BE%E4%B8%8D%E5%88%B0-Cocoapods-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天遇到了使用 AS 运行 flutter app 时，会爆出找不到 cocoapods 的问题，尝试过重新安装 Android studio 的方式，仍然未解决。</p>
<p>解决方案是在终端中，使用 open 命令打开 AS 即可，判断是 AS 中的环境变量与系统终端中的环境变量不一致导致找不到 cocoapods 导致的问题</p>
]]></content>
  </entry>
  <entry>
    <title>AnchorPoint 与 transform 和 frame 的关系</title>
    <url>/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>在我们应用 2d 仿射变换的时候，一般都是遵循 缩放、旋转、平移的顺序来的，在 iOS 也是如此。</p>
<p>不过有一些不一样的地方，我们在学习图形学的时候，参考点都是坐标原点，类似于这样。<br><img src="/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/1.jpg"></p>
<p>iOS 则是参考的 view 中点，即 (0.5, 0.5)，以两个例子说明，图中的棋盘格尺寸为 50x50，view 的初始 frame 为 {0,0,50,50}<br><img src="/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/2.jpg"><br><img src="/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/3.jpg"></p>
<p>依据旋转、缩放、平移的顺序进行解析</p>
<p><strong>先是上面的图</strong></p>
<p>需要先将 x、y 轴放大到原来的两倍再进行平移，一开始的中心点是{25,25}，图中的中心点为{50,50}，所以需要平移{25,25}</p>
<p>代码如下<br><img src="/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/4.jpg"></p>
<p><strong>再是下面的图</strong></p>
<p>观察得出图形首先旋转了45度，然后图中的边长 1.5 * 1.414（√2） * 50，所以相对于原图，在 x、y 轴上都放大了 1.5 * 1.414（√2）倍，最后观察中心点，平移了{100,100}</p>
<p>所以代码如下<br><img src="/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/5.jpg"></p>
<p>至于 anchorPoint，不需要进行改动，至于它的作用，可以理解为用来定位 layer 的显示位置，将 view 点的中点与 layer 中 anchorPointt 对应的位置“锚定”起来。</p>
<p>下图依次是 anchorPoint &#x3D; {0,0}{0.5,0.5}{1.0,1.0}所展示的样子<br><img src="/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/6.png"><br><img src="/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/7.jpg"><br><img src="/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/8.jpg"></p>
<p>iOS 16 新出了个 CGAffineTransformComponents，再也不用担心搞错了旋转平移的顺序导致结果出错了<br><img src="/2022/09/26/AnchorPoint-%E4%B8%8E-transform-%E5%92%8C-frame-%E7%9A%84%E5%85%B3%E7%B3%BB/9.jpg"></p>
<p>使用 CGAffineTransformMakeWithComponents 方法来将它转换成所需的 CGAffineTransform 即可。</p>
]]></content>
  </entry>
  <entry>
    <title>App保活</title>
    <url>/2016/05/19/App%E4%BF%9D%E6%B4%BB/</url>
    <content><![CDATA[<p>已废弃</p>
<p>目前可以直接增加后台模式，选择合适的功能即可<br><img src="/2016/05/19/App%E4%BF%9D%E6%B4%BB/1.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Chrromium开发参考</title>
    <url>/2020/07/20/Chrromium%E5%BC%80%E5%8F%91%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h3 id="Working-With-Files"><a href="#Working-With-Files" class="headerlink" title="Working With Files"></a>Working With Files</h3><p><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/ios/working_with_files.md">https://chromium.googlesource.com/chromium/src/+/master/docs/ios/working_with_files.md</a></p>
<h3 id="Developing-Chrome-for-iOS-with-the-Xcode-IDE"><a href="#Developing-Chrome-for-iOS-with-the-Xcode-IDE" class="headerlink" title="Developing Chrome for iOS with the Xcode IDE"></a>Developing Chrome for iOS with the Xcode IDE</h3><p><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/ios/xcode_tips.md">https://chromium.googlesource.com/chromium/src/+/master/docs/ios/xcode_tips.md</a></p>
<h3 id="Chromium-docs"><a href="#Chromium-docs" class="headerlink" title="Chromium docs"></a>Chromium docs</h3><p><a href="https://chromium.googlesource.com/chromium/src.git/+/master/docs/README.md">https://chromium.googlesource.com/chromium/src.git/+/master/docs/README.md</a>	</p>
<h3 id="Adding-third-party-Libraries"><a href="#Adding-third-party-Libraries" class="headerlink" title="Adding third_party Libraries"></a>Adding third_party Libraries</h3><p><a href="https://chromium.googlesource.com/chromium/src.git/+/master/docs/adding_to_third_party.md">https://chromium.googlesource.com/chromium/src.git/+/master/docs/adding_to_third_party.md</a></p>
<h3 id="GN-command-list"><a href="#GN-command-list" class="headerlink" title="GN command list"></a>GN command list</h3><p><a href="https://gn.googlesource.com/gn/+/master/docs/reference.md#func_template">https://gn.googlesource.com/gn/+/master/docs/reference.md#func_template</a></p>
<h3 id="搜索引擎图标"><a href="#搜索引擎图标" class="headerlink" title="搜索引擎图标"></a>搜索引擎图标</h3><p>loadDefaultSearchEngineFaviconWithCompletion</p>
<h3 id="查看entitlement"><a href="#查看entitlement" class="headerlink" title="查看entitlement"></a>查看entitlement</h3><p>codesign -d –entitlements - xxx.app</p>
<h3 id="解码-mobileprovision-文件"><a href="#解码-mobileprovision-文件" class="headerlink" title="解码 mobileprovision 文件"></a>解码 mobileprovision 文件</h3><p>security cms -D -i input.mobileprovision -o output.mobileprovision</p>
<h3 id="Keychain-Sharing"><a href="#Keychain-Sharing" class="headerlink" title="Keychain Sharing"></a>Keychain Sharing</h3><p>keychain-access-groups</p>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>codesign.py<br>4个 Action<br>Xcode build 时调用<br>CodeSignBundleAction -&gt;<br>GenerateEntitlements -&gt;<br>LoadDefaults -&gt;</p>
<h3 id="ios-x2F-build-x2F-tools-x2F-setup-gn-py"><a href="#ios-x2F-build-x2F-tools-x2F-setup-gn-py" class="headerlink" title="ios&#x2F;build&#x2F;tools&#x2F;setup-gn.py"></a>ios&#x2F;build&#x2F;tools&#x2F;setup-gn.py</h3><p>FindProvisioningProfileAction</p>
<h3 id="设备列表"><a href="#设备列表" class="headerlink" title="设备列表"></a>设备列表</h3><p>xcrun xctrace list devices</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>No such file or directory<br>解决方法<br>使用低版本Xcode和手机</p>
<h3 id="搜索多个文件里面的内容"><a href="#搜索多个文件里面的内容" class="headerlink" title="搜索多个文件里面的内容"></a>搜索多个文件里面的内容</h3><p>find . -name “*.gn” | xargs grep “&#x2F;&#x2F;ios&#x2F;web:web”</p>
<h3 id="生成MD5文件"><a href="#生成MD5文件" class="headerlink" title="生成MD5文件"></a>生成MD5文件</h3><p>md5sum file &gt; file.md5</p>
<h3 id="比较MD5"><a href="#比较MD5" class="headerlink" title="比较MD5"></a>比较MD5</h3><p>md5sum -c a.md5</p>
<h3 id="选择-Xcode-Command-Line-Tool"><a href="#选择-Xcode-Command-Line-Tool" class="headerlink" title="选择 Xcode Command Line Tool"></a>选择 Xcode Command Line Tool</h3><p>sudo xcode-select –switch path&#x2F;to&#x2F;Xcode.app</p>
<h3 id="打印证书"><a href="#打印证书" class="headerlink" title="打印证书"></a>打印证书</h3><p>security find-identity</p>
]]></content>
  </entry>
  <entry>
    <title>CocoaPods 小技巧</title>
    <url>/2017/01/29/CocoaPods-%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="依赖库无法拉取的问题"><a href="#依赖库无法拉取的问题" class="headerlink" title="依赖库无法拉取的问题"></a>依赖库无法拉取的问题</h2><h3 id="代理开启方式"><a href="#代理开启方式" class="headerlink" title="代理开启方式"></a>代理开启方式</h3><p>pod 拉取 BIJKPlayer 时一直失败，设置终端代理后解决</p>
<ol>
<li>pod install 使用 curl 下载库文件，所以需要配置 ~&#x2F;.curlrc 文件（如果没有新建一个），里面加上 socks&#x3D;”<a href="http://127.0.0.1:10000"，保存后重启终端，即可解决">http://127.0.0.1:10000&quot;，保存后重启终端，即可解决</a></li>
<li>打开终端后执行 （仅对当前终端有效）<br>export all_proxy&#x3D;<a href="http://127.0.0.1:9999/">http://127.0.0.1:9999/</a><br>export http_proxy&#x3D;<a href="http://127.0.0.1:9999/">http://127.0.0.1:9999/</a><br>export https_proxy&#x3D;<a href="https://127.0.0.1:9999/">https://127.0.0.1:9999/</a><br>开启终端代理</li>
</ol>
<h3 id="手动下载方式"><a href="#手动下载方式" class="headerlink" title="手动下载方式"></a>手动下载方式</h3><p>以 GoogleAppMeasurement (6.8.0) 为例，执行pod install 后，终端输出如下所示</p>
<pre><code>-&gt; Installing GoogleAppMeasurement (6.8.0)
Http download
$ /usr/bin/curl -f -L -o /var/folders/sw/lnv_fnsd3jn39d99prhj8hsw0000gn/T/d20210113-18255-6teud4/file.tgz https://dl.google.com/firebase/ios/analytics/bd6d5b2fbdd98275/GoogleAppMeasurement-6.8.0.tar.gz --create-dirs --netrc-optional --retry 2
</code></pre>
<p>手动下载 .gz 文件后，解压至 ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;Pods&#x2F;Release&#x2F;GoogleAppMeasurement&#x2F;6.8.0-<font color=#FF0000>18255</font>&#x2F; 目录下，注意红字部分（<font color=#FF0000>18255</font>）一致，重新运行 pod install 即可。</p>
]]></content>
  </entry>
  <entry>
    <title>CollectionView Layout 问题</title>
    <url>/2022/10/13/CollectionView-Layout-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天发现了个奇怪的问题，批量抠图的时候使用了 UICollectionView 进行布局，如果将 itemSize 设置为相同的，那么显示正常，但如果设置为原图，即每个 cell.size 都不一样，就会出现无法滑动到底部，导致最后几个 cell 无法显示的问题。</p>
<p>为此我专门写了个 Demo 进行测试，发现没有问题，但是布局和佐糖的有点区别，如图所示，我设置的每行都是两个 cell<br><img src="/2022/10/13/CollectionView-Layout-%E9%97%AE%E9%A2%98/1.jpg"><br><img src="/2022/10/13/CollectionView-Layout-%E9%97%AE%E9%A2%98/2.jpg"><br><img src="/2022/10/13/CollectionView-Layout-%E9%97%AE%E9%A2%98/3.jpg"></p>
<p>三张图分别是</p>
<p>Demo - 相同 ItemSize</p>
<p>Demo - 不同 ItemSize</p>
<p>佐糖 - 不同 ItemSize（原图）</p>
<p>可以看到，即使设置了不同的 itemSize，佐糖的布局仍然是每行两个，检查代码后发现是由于佐糖使用了自定义的 layout（继承自 UICollectionViewFlowLayout），初步判断是由于自定义 layout 影响了 contentSize，导致其计算不正确导致无法完全显示。</p>
<p>检查代码后发现自定义 layout 重写了这两个方法<br><img src="/2022/10/13/CollectionView-Layout-%E9%97%AE%E9%A2%98/4.jpg"></p>
<p>点击进入 UICollectionViewFlowLayout 的头文件里看了看，没啥发现，然后进入下一个父类 UICollectionViewLayout，发现问题了，这里有一行<br><img src="/2022/10/13/CollectionView-Layout-%E9%97%AE%E9%A2%98/5.jpg"></p>
<p>它的大致意思是，如果重写了布局，需要指定新的 contentSize 来保证每个 cell 都可以正常显示。初步判断问题就在这里。</p>
]]></content>
  </entry>
  <entry>
    <title>Fastlane 使用 increment_build_number 导致build版本号修改不生效的问题</title>
    <url>/2022/12/07/Fastlane-%E4%BD%BF%E7%94%A8-increment-build-number-%E5%AF%BC%E8%87%B4build%E7%89%88%E6%9C%AC%E5%8F%B7%E4%BF%AE%E6%94%B9%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>使用 Fastlane 进行打包的时候，如果使用了 increment_build_number，它会修改 Info.plist 中与 build 版本号相关的值（Bundle version），导致它与 General 中的 build 版本号断开关联，后续即使在这里修改也不会生效，在我们上传到商店时不是很方便</p>
<p>建议还是改回工程默认配置</p>
<p><img src="/2022/12/07/Fastlane-%E4%BD%BF%E7%94%A8-increment-build-number-%E5%AF%BC%E8%87%B4build%E7%89%88%E6%9C%AC%E5%8F%B7%E4%BF%AE%E6%94%B9%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1.jpg"></p>
<p>至于 Info.plist 中的 CURRENT_PROJECT_VERSION，MARKETING_VERSION 等宏是什么意思，可以查看 Xcode help</p>
<p><img src="/2022/12/07/Fastlane-%E4%BD%BF%E7%94%A8-increment-build-number-%E5%AF%BC%E8%87%B4build%E7%89%88%E6%9C%AC%E5%8F%B7%E4%BF%AE%E6%94%B9%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/2.jpg"><br><img src="/2022/12/07/Fastlane-%E4%BD%BF%E7%94%A8-increment-build-number-%E5%AF%BC%E8%87%B4build%E7%89%88%E6%9C%AC%E5%8F%B7%E4%BF%AE%E6%94%B9%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/3.jpg"></p>
<p>可以搜索到相关信息</p>
]]></content>
  </entry>
  <entry>
    <title>Flutter TDD Clean Architecture</title>
    <url>/2022/06/07/Flutter-TDD-Clean-Architecture/</url>
    <content><![CDATA[<p><img src="/2022/06/07/Flutter-TDD-Clean-Architecture/1.png"></p>
<p>它将 App 分为了三个部分</p>
<ul>
<li>Presentation（表现层）</li>
<li>Domain（域？层）</li>
<li>Data（数据层）</li>
</ul>
<p>其中 Domain 层作为中间层，是与 UI 和 底层分开的，它负责了 App 业务处理。</p>
<p>可以看到 Repository 横跨了两个层，Domain 层的部分作为 Abstract Class，与底层分割开。</p>
<p>Data 层部分作为实体类，与底层进行交互。</p>
<p>这样既做到了分离，也增加了可测试性，因为 Repository 是一个抽象类，那么我们既可以跑在实体类上执行正常的业务逻辑，也可以跑在 Mock 类上进行我们的单元测试或者集成测试。</p>
<h3 id="Dependency-Injection-amp-Dependency-Inversion（依赖注入与依赖反转）"><a href="#Dependency-Injection-amp-Dependency-Inversion（依赖注入与依赖反转）" class="headerlink" title="Dependency Injection &amp; Dependency Inversion（依赖注入与依赖反转）"></a>Dependency Injection &amp; Dependency Inversion（依赖注入与依赖反转）</h3><p>从网络获取数据的情况</p>
<p>如果类 A 中某个方法需要类 B 中的方法来实现（例如管理类通过网络获取数据），应当在构造 A 时，将 B 作为参数传入，而不是为 A 添加一个属性用来保存 B 的实例。（依赖注入）</p>
<p>如果同时还需要从缓存获取数据的功能</p>
<p>可以将 B 进行抽象，并构造相应的实体类（网络源，缓存源），修改传入的参数类型为抽象类，通过传入不同的实体类来完成不同的个功能。（依赖反转）</p>
<p>同时增加了可测试性。</p>
<p>在 TDD 开发模式中，我们首先写测试代码，然后开始写功能代码，这可以保证两点：</p>
<ol>
<li>避免出现无效代码的代码（<a href="https://en.wikipedia.org/wiki/You_aren't_gonna_need_it">YAGNI</a>）</li>
<li>在修改了某个功能后，只需要执行一次测试，就可以知道是否影响了其他的功能。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>GPUImageBrightnessFilter 导致透明区域泛白的问题</title>
    <url>/2022/12/28/GPUImageBrightnessFilter-%E5%AF%BC%E8%87%B4%E9%80%8F%E6%98%8E%E5%8C%BA%E5%9F%9F%E6%B3%9B%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>使用GPUImage 自带的 GPUImageBrightnessFilter 滤镜对图片进行美白处理时，发现透明部分也被提亮了，检察源码后发现它直接使用了 OpenGL 来处理图片，直接将rgb值乘以亮度，导致透明部分也会被提亮，如图所示<br><img src="/2022/12/28/GPUImageBrightnessFilter-%E5%AF%BC%E8%87%B4%E9%80%8F%E6%98%8E%E5%8C%BA%E5%9F%9F%E6%B3%9B%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/1.png"></p>
<p>这里只需要将着色器代码修改一下，将亮度值再乘以alpha，越透明的地方受亮度影响越小即可<br><img src="/2022/12/28/GPUImageBrightnessFilter-%E5%AF%BC%E8%87%B4%E9%80%8F%E6%98%8E%E5%8C%BA%E5%9F%9F%E6%B3%9B%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/2.png"></p>
<p>效果如下<br><img src="/2022/12/28/GPUImageBrightnessFilter-%E5%AF%BC%E8%87%B4%E9%80%8F%E6%98%8E%E5%8C%BA%E5%9F%9F%E6%B3%9B%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/3.jpg"><br><img src="/2022/12/28/GPUImageBrightnessFilter-%E5%AF%BC%E8%87%B4%E9%80%8F%E6%98%8E%E5%8C%BA%E5%9F%9F%E6%B3%9B%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/4.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>HTTP 范围请求与 HTTP 条件请求详解</title>
    <url>/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="HTTP-范围请求"><a href="#HTTP-范围请求" class="headerlink" title="HTTP 范围请求"></a>HTTP 范围请求</h1><p>HTTP 协议范围请求允许服务器只发送 HTTP 消息的一部分到客户端。范围请求在传送大的媒体文件，需要文件下载的断点续传功能时非常有用。</p>
<h2 id="检测服务器端是否支持范围请求-可以使用-HEAD-方式请求某个资源，获取响应头"><a href="#检测服务器端是否支持范围请求-可以使用-HEAD-方式请求某个资源，获取响应头" class="headerlink" title="检测服务器端是否支持范围请求,可以使用 HEAD 方式请求某个资源，获取响应头"></a>检测服务器端是否支持范围请求,可以使用 HEAD 方式请求某个资源，获取响应头</h2><pre><code class="bash">➜ curl -I localhost/1.txt
HTTP/1.1 200 OK
......
Content-Length: 10
Accept-Ranges: bytes
</code></pre>
<p>在上面的响应中，Accept-Ranges: bytes 表示界定范围的单位是字节。这里 Content-Length 提供了请求资源的完整大小。</p>
<p>如果返回了 Accept-Ranges: none，说明该资源不支持范围请求，或者未返回 Accept-Ranges 首部，也可以将其理解为不支持。</p>
<h2 id="从服务器端请求特定的范围，使用-Range-首部来界定资源的范围"><a href="#从服务器端请求特定的范围，使用-Range-首部来界定资源的范围" class="headerlink" title="从服务器端请求特定的范围，使用 Range 首部来界定资源的范围"></a>从服务器端请求特定的范围，使用 Range 首部来界定资源的范围</h2><h3 id="单一范围"><a href="#单一范围" class="headerlink" title="单一范围"></a>单一范围</h3><pre><code class="bash">➜ curl -i localhost/1.txt -H &quot;Range: bytes=0-1&quot;
HTTP/1.1 206 Partial Content
......
Content-Length: 2
Content-Range: bytes 0-1/10

01
</code></pre>
<p>Content-Length 首部现在用来表示当前文件分片的大小（而不是整个文件的大小）  <br>Content-Range 响应首部则表示这一部分内容在整个资源中所处的位置。</p>
<h3 id="多重范围"><a href="#多重范围" class="headerlink" title="多重范围"></a>多重范围</h3><p>Range 头部也支持一次请求文档的多个部分。请求范围用一个逗号分隔开。</p>
<pre><code class="bash">➜ curl -i localhost/1.txt -H &quot;Range: bytes=0-1, 4-5&quot;
HTTP/1.1 206 Partial Content
......
Content-Type: multipart/byteranges; boundary=00000000000000000003
Content-Length: 198


--00000000000000000003
Content-Type: text/plain
Content-Range: bytes 0-1/10

01
--00000000000000000003
Content-Type: text/plain
Content-Range: bytes 4-5/10

45
--00000000000000000003--
</code></pre>
<p>服务器返回</p>
<p>状态码：206 Partial Content</p>
<p>头部：Content-Type：multipart&#x2F;byteranges; boundary&#x3D;3d6b6a416f9b5</p>
<p>Content-Type：multipart&#x2F;byteranges 表示这个响应有多个 byterange。每一部分 byterange 都有他自己的 Content-Type 头部和 Content-Range，并且使用 boundary 参数对 body 进行划分。</p>
<h2 id="条件式范围请求"><a href="#条件式范围请求" class="headerlink" title="条件式范围请求"></a>条件式范围请求</h2><p>范围请求的响应</p>
<ol>
<li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li>
<li>在请求的范围越界的情况下（范围值超过了资源的大小），服务器会返回 416 Requested Range Not Satisfiable （请求的范围无法满足）状态码</li>
<li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li>
<li>增加了条件请求且符合条件的情况下，按照1、2、3条说明的内容进行返回，不满足条件时返回整个文件并返回 200 OK 状态吗</li>
</ol>
<h1 id="HTTP-条件请求"><a href="#HTTP-条件请求" class="headerlink" title="HTTP 条件请求"></a>HTTP 条件请求</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>在 HTTP 协议中，条件请求指的是请求的执行结果会因特定首部的值不同而不同。这些首部规定了请求的前置条件，请求结果则视条件匹配与否而有所不同。</p>
<p>请求引发的不同的反应取决于请求所使用的方法，以及组成前置条件首部集合：</p>
<ul>
<li>对于安全（safe）方法来说，例如 GET，通常用来获取文件，条件请求可以被用来限定仅在满足条件的情况下返回文件。这样可以节省带宽。</li>
<li>对于非安全（unsafe）方法来说，例如 PUT 方法，通常用来上传文件，条件请求可以被用来限定仅在满足文件的初始版本与服务器上的版本相同的条件下才会将其上传。</li>
</ul>
<p>安全与非安全可以用是否改变了服务器的内容来进行界定，改变了服务器内容即非安全方法，反之则是安全方法</p>
<h2 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h2><p>所有的条件请求首部都是试图去检测服务器上存储的资源是否与某一特定版本相匹配。为了达到这个目的，条件请求需要指明资源的版本。由于逐个字节去比较完整资源是不切实际的，况且这也并非总是想要的结果，所以在请求中会传递一个描述资源版本的值。这些值称为“验证器”，并且分为两大类：</p>
<ul>
<li>Last-Modified，文件的最后修改时间</li>
<li>Etag，实体标签，一个意义模糊的字符串，代表了一个独一无二的版本</li>
</ul>
<p>比较同一份资源的不同版本有一定的技巧性：取决于上下文环境的不同，有两种不同的等值检查（equality checks）类型：</p>
<ul>
<li>强验证类型（Strong validation）应用于需要逐个字节相对应的情况，例如需要进行断点续传的时候。</li>
<li>弱验证类型（Weak validation）应用于用户代理只需要确认资源内容相同即可。即便是有细微差别也可以接受，比如显示的广告不同，或者是页脚的时间不同。</li>
</ul>
<p>验证类型与验证器的类型是相互独立的。 Last-Modified 和 ETag 首部均可应用于两种验证类型，尽管在服务器端实现的复杂程度可能会有所不同。HTTP 协议默认使用强验证类型，可以指定何时使用弱验证类型。</p>
<h2 id="强验证类型"><a href="#强验证类型" class="headerlink" title="强验证类型"></a>强验证类型</h2><p>强验证类型的作用在于确保要比较的资源与其相比较的对象之间每一个字节都相同。对于有些首部来说需要明确指定该验证类型，而对于另外一些来说则是默认值就是强验证类型。强验证类型的要求相当严格，在服务器层面来说可能较难保证。但是它确保了数据在任何时候都没有缺损，有时候则需要以牺牲性能为代价。</p>
<p>使用 Last-Modified 首部很难为强验证类型提供一个唯一标识。通常这是由 ETag 首部来完成的，该首部可以提供使用 MD5 算法获取的资源（或其衍生品）的散列值。</p>
<h2 id="弱验证类型"><a href="#弱验证类型" class="headerlink" title="弱验证类型"></a>弱验证类型</h2><p>弱验证类型与强验证类型不同，因为它会把内容相同的两份文件看做是一样的。例如，使用弱验证类型，一个页面与另外一个页面只是在页脚显示的时间上有所不同，或者是展示的广告不相同，那么就会被认为是相同的。但是在使用强验证的情况下，二者是不同的。构建应用于弱验证类型的标签（etag）体系可能会比较复杂，因为这会涉及到对页面上不同的元素的重要性进行排序，但是会对缓存性能优化相当有帮助。</p>
<h2 id="条件首部"><a href="#条件首部" class="headerlink" title="条件首部"></a>条件首部</h2><p>一些被称为条件首部的 HTTP 首部，可以引发条件请求。它们是：</p>
<p><strong>If-Match</strong></p>
<p>如果远端资源的实体标签与在 ETag 这个首部中列出的值相同的话，表示条件匹配成功。默认地，除非实体标签带有 ‘W&#x2F;‘ 前缀，否者它将会执行强验证。</p>
<p><strong>If-None-Match</strong></p>
<p>如果远端资源的实体标签与在 ETag 这个首部中列出的值都不相同的话，表示条件匹配成功。默认地，除非实体标签带有 ‘W&#x2F;‘ 前缀，否者它将会执行强验证。</p>
<p><strong>If-Modified-Since</strong></p>
<p>如果远端资源的 Last-Modified 首部标识的日期比在该首部中列出的值要更晚，表示条件匹配成功。</p>
<p><strong>If-Unmodified-Since</strong></p>
<p>如果远端资源的 Last-Modified 首部标识的日期比在该首部中列出的值要更早或相同，表示条件匹配成功。</p>
<p><strong>If-Range</strong></p>
<p>与 If-Match 或 If-Unmodified-Since 相似，但是只能含有一个实体标签或者日期值。如果匹配失败，则条件请求宣告失败，此时将不会返回 206 Partial Content 响应码，而是返回 200 OK 响应码，以及完整的资源。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>条件式请求最常见的应用场景是更新缓存。假如缓存为空，或者是没有缓存的话，被请求资源会以状态码 200 OK 返回，这里以一个内容为“0123456789”的文本文件为例。<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/1.png"></p>
<pre><code class="bash">➜ curl -i localhost/1.txt
HTTP/1.1 200 OK
......
Last-Modified: Wed, 04 Jan 2023 03:26:15 GMT
ETag: &quot;63b4f1d7-a&quot;

0123456789
</code></pre>
<p>服务器响应后，验证器会同资源一起返回，它们出现在首部字段中。</p>
<p>在这个例子中， Last-Modified 与 ETag 都被返回，不过如果只返回其中的一个也是可以的。这些验证器会同资源一起被缓存起来（需要客户端实现，与所有的首部一样），并在在缓存失效的时候用来发起条件式请求。</p>
<p>只要缓存未失效，就不会发起任何请求。但是一旦失效——主要是由 Cache-Control 首部控制——客户端就不会采用缓存值而是发起条件式请求。验证器的值会用作 If-Modified-Since 和 If-Match 首部字段的参数。</p>
<p>假如资源未发生变化，服务器就返回状态码为 304 Not Modified 的响应。这样相当于对缓存资源进行了刷新，而客户端则采用被缓存的资源。尽管这里有一次请求&#x2F;响应往返会消耗一定的资源，但是这样做比将整个资源通过网络再传输一遍更高效。如图所示<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/2.png"></p>
<pre><code class="bash">➜ curl -i localhost/1.txt -H &quot;If-Modified-Since: Wed, 04 Jan 2023 03:26:15 GMT
If-None-Match: \&quot;63b4f1d7-a\&quot;&quot;
HTTP/1.1 304 Not Modified
......
</code></pre>
<p>假如资源发生了变化（这里向文件末尾添加一个“0”），服务器就直接返回 200 OK 响应码，连同新版本的资源，就像是没有应用条件式请求一样；客户端则采用新版本资源（并将其缓存起来）。<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/3.png"></p>
<pre><code class="bash">➜ curl -i localhost/1.txt -H &quot;If-Modified-Since: Wed, 04 Jan 2023 03:26:15 GMT
If-None-Match: \&quot;63b4f1d7-a\&quot;&quot;
HTTP/1.1 200 OK
......
Last-Modified: Wed, 04 Jan 2023 06:38:46 GMT
ETag: &quot;63b51ef6-b&quot;

01234567890
</code></pre>
<p>除了需要在服务器端对验证器进行设置以外，该机制是透明的：所有的浏览器都会对缓存资源进行管理，在不需要 Web 开发者进行任何特殊处理的情况下发送条件式请求。</p>
<h3 id="增量下载的完整性"><a href="#增量下载的完整性" class="headerlink" title="增量下载的完整性"></a>增量下载的完整性</h3><p>文件的增量下载是 HTTP 协议规定的一项功能，它允许恢复先前的操作，通过保存先前已经获得的信息来节省带宽和时间，支持增量下载的服务器会通过 Accept-Ranges 首部来广播这项能力，这里以一个内容为“1234”的文本文件为例<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/4.png"></p>
<pre><code class="bash">➜ curl -i localhost/1.txt -H &quot;Range: bytes=0-1&quot;
HTTP/1.1 200 OK
...
Accept-Ranges: bytes

12
➜ curl -i localhost/1.txt -H &quot;Range: bytes=2-3&quot;
HTTP/1.1 200 OK
...
Accept-Ranges: bytes

34
</code></pre>
<p>下载的文本文件的内容为“1234”，与源文件一致。</p>
<p>但是这里有一个潜在的问题：如果要下载的资源在两次下载之间进行了修改，得到的数据范围就会对应该资源的两个不同的版本，那么最终获得的文件是损坏的。例如</p>
<pre><code class="bash">➜ curl -i localhost/1.txt -H &quot;Range: bytes=0-1&quot;
HTTP/1.1 206 Partial Content
...
Content-Range: bytes 0-1/4

12
此时将文件内容改为“4567”，然后继续下载
➜ curl -i localhost/1.txt -H &quot;Range: bytes=2-3&quot;
HTTP/1.1 206 Partial Content
...
Content-Range: bytes 2-3/4

67                                                                       
</code></pre>
<p>下载的文本文件的内容为“1267”，与源文件不一致。<br>为了防止这种情况的发生，需要使用条件式请求。对于范围请求来说，有两种方法可以实现这个目的。第一种是使用 If-Unmodified-Since 和 If-Match 首部，假如前置条件失败，服务器端会返回错误提示，然后客户端可以从头开始重新下载资源，如图所示<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/5.png"></p>
<pre><code class="bash">~ curl -i localhost/1.txt -H &quot;Range: bytes=0-1&quot;
HTTP/1.1 206 Partial Content
......
Last-Modified: Wed, 04 Jan 2023 07:31:18 GMT
ETag: &quot;63b52b46-4&quot;
Content-Range: bytes 0-1/4

12
</code></pre>
<p>此时将文件内容改为“4567”</p>
<pre><code class="bash">~ curl -i localhost/1.txt -H &quot;Range: bytes=2-3
If-Unmodified-Since: Wed, 04 Jan 2023 07:31:18 GMT
If-Match: \&quot;63b52b46-4\&quot;&quot;
HTTP/1.1 412 Precondition Failed
...
</code></pre>
<p>服务器返回条件验证不成功，客户端此时就可以重新下载文件，保证文件的完整性，尽管这种方法行得通，但是它在文件发生变化的情况下增加了一次额外的请求&#x2F;响应往返。这一点会影响性能。为此 HTTP 协议规定了一个特定的首部 If-Range 来避免这种情况的发生，也就是第二种方法<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/6.png"></p>
<pre><code class="bash">➜ curl -i localhost/1.txt -H &quot;Range: bytes=0-1&quot;
HTTP/1.1 206 Partial Content
......
Last-Modified: Wed, 04 Jan 2023 07:35:10 GMT
ETag: &quot;63b52c2e-4&quot;
Content-Range: bytes 0-1/4

12                                                                                  
</code></pre>
<p>此时改变文件内容为“4567”</p>
<pre><code class="bash">➜ curl -i localhost/1.txt -H &quot;Range: bytes=2-3
dquote&gt; If-Range: \&quot;63b52c2e-4\&quot;&quot;
HTTP/1.1 200 OK
......
Last-Modified: Wed, 04 Jan 2023 07:35:33 GMT
ETag: &quot;63b52c45-4&quot;
Accept-Ranges: bytes

4567
</code></pre>
<p>这个方法也有一个缺点，就是如果文件被修改了，第二次就回全量下载文件，增量下载就失效了。</p>
<h3 id="使用乐观锁避免更新丢失问题"><a href="#使用乐观锁避免更新丢失问题" class="headerlink" title="使用乐观锁避免更新丢失问题"></a>使用乐观锁避免更新丢失问题</h3><p>在远程更新文件的情况下。客户端首先读取原始文件，修改后，最后使用 PUT 方法将它们推送到服务器上<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/7.png"></p>
<p>但是当把并发情况考虑在内的时候，事情变得有些不那么确定。当有多个用户都进行该操作的时候，会导致难以捉摸的情况的发生，最终服务器保存的文件内容是不确定的，每一次的胜出者都会有所不同。这种情况被称作竞态条件（race condition ），难以探测和除错<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/8.png"></p>
<p>不存在解决这一问题而不打扰双方某一方的办法。然而，更新丢失问题以及竞态条件是需要避免的。我们希望获得可预测的结果，并且希望在更新操作被拒绝的时候客户端可以得到反馈。</p>
<p>这个时候可以使用条件式请求。其思路是，允许所有的客户端获得资源的副本，然后在本地进行编辑，通过只允许第一个客户端成功提交的方式来控制并发操作。其余的基于现今已过期版本的更新操作都会被拒绝：<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/9.png"></p>
<p>这种方式的实现需要用到 If-Match 或 If-Unmodified-Since 首部。假如实体标签与源头文件的实体标签不一致，或者源头文件在被获取副本之后经过了修改，那么此次变更请求就会被拒绝，收到 412 Precondition Failed 的错误提示。之后就需要依靠客户端来处理该错误了：或者通知用户重新开始（基于最新的版本），或者是给用户展示两个版本之间的差异，辅助他们决定要保留哪些变更。</p>
<h3 id="处理资源的首次上传问题"><a href="#处理资源的首次上传问题" class="headerlink" title="处理资源的首次上传问题"></a>处理资源的首次上传问题</h3><p>资源的首次上传问题是前面所描述的情况的一个极端情况。与任何资源更新问题一样，当两个客户端在大致相同的时间进行上传操作的时候，就会遇到竞态条件。为了防止这种情况的发生，可以使用条件式请求：添加 If-None-Match 首部，并将其值设置为’*’, 表示任意实体标签。当且仅当资源先前并不存在的情况下请求的操作才会成功执行：<br><img src="/2023/01/06/HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%E4%B8%8E-HTTP-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%E8%AF%A6%E8%A7%A3/10.png"></p>
<p>If-None-Match 首部只可应用于兼容 HTTP&#x2F;1.1（及后续版本）的服务器。假如不确定所访问的服务器是否兼容，需要首先向要访问的资源发送一次 HEAD 请求来进行确</p>
]]></content>
  </entry>
  <entry>
    <title>IP地址</title>
    <url>/2015/11/11/IP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h2 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h2><p>IP地址&#x3D;网络地址+主机地址，例如<br>192.168.1(网络地址).1(主机地址)</p>
<h2 id="IP地址的类型"><a href="#IP地址的类型" class="headerlink" title="IP地址的类型"></a>IP地址的类型</h2><h3 id="公有地址"><a href="#公有地址" class="headerlink" title="公有地址"></a>公有地址</h3><p>公有地址（Public address）由Inter NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问因特网</p>
<h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3><p>私有地址（Private address）属于非注册地址，专门为组织机构内部使用。以下列出留用的内部私有地址A类 10.0.0.0–10.255.255.255B类 172.16.0.0–172.31.255.255C类 192.168.0.0–192.168.255.255</p>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p>IPv4一共32位，分成网络号和主机号，分为五类，即ABCDE </p>
<p>A类 - 网络号8位，0开头；主机号24位 </p>
<p>B类 - 网络号16位，10开头；主机号16位 </p>
<p>C类 - 网络号24位，110开头；主机号8位 </p>
<h2 id="特殊的网络号"><a href="#特殊的网络号" class="headerlink" title="特殊的网络号"></a>特殊的网络号</h2><p>全0主机号代表当前网络段<br>全1主机号代表广播地址</p>
<h2 id="特殊的主机号"><a href="#特殊的主机号" class="headerlink" title="特殊的主机号"></a>特殊的主机号</h2><p>A类地址网络段全为0（00000000）表示特殊网络，不能直接使用<br>A类地址网络段后7位全为1（01111111）表示回环地址，不能直接使用<br>B类地址网络段全为0（10000000.00000000:128.0）不能使用<br>C类地址网络段全为0（11000000）是不可使用的</p>
<table>
<thead>
<tr>
<th align="left">最小网络号</th>
<th align="left">最大网络号</th>
<th align="left">子网数量</th>
<th align="left">最小主机号</th>
<th align="left">最大主机号</th>
<th align="left">主机数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A</td>
<td align="left">1</td>
<td align="left">127</td>
<td align="left">2^7-2 &#x3D; 126</td>
<td align="left">0.0.1</td>
<td align="left">255.255.254</td>
</tr>
<tr>
<td align="left">B</td>
<td align="left">128.1</td>
<td align="left">191.255</td>
<td align="left">2^14-1</td>
<td align="left">0.1</td>
<td align="left">255.254</td>
</tr>
<tr>
<td align="left">C</td>
<td align="left">192.0.1</td>
<td align="left">223.255.255</td>
<td align="left">2^21-1</td>
<td align="left">1</td>
<td align="left">254</td>
</tr>
</tbody></table>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p>D类 - 网络号（8、16、24位）+1位子网号+主机号</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>24位<br>由连续个1和连续个0组成 </p>
<p>网络号位数个连续的1（A类 - 255.0.0.0，B类 - 255.255.0.0，C类 - 255.255.255.0）</p>
]]></content>
  </entry>
  <entry>
    <title>GetX多语言使用方法</title>
    <url>/2021/10/22/GetX%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>又到了分享时刻，今天看了下 GetX，发现了一个应用内切换语言的功能，不需要重启 App 即可完成语言的切换，而且配置简单，只需要几步即可完成</p>
<p>1、创建一个 Translations 类来存放你的多语言文案，例如<br><img src="/2021/10/22/GetX%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/1.jpg">￼</p>
<p>2、修改 GetMaterialApp 的相应参数<br><img src="/2021/10/22/GetX%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/2.jpg"></p>
<p>其中 Message 是存放多语言文案的类<br>locale 指定当前 App 的语言<br>fallbackLocale 指定当找不到对应语言的文案时，该使用哪种语言作为默认多语言文案</p>
<p>3、使 App 中的文案随着语言变化<br><img src="/2021/10/22/GetX%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/3.jpg"><br> <br>对，只需要在 String 类对象后面加上 “.tr“ 即可，非常方便。</p>
<p>4、最后一步，切换多语言<br><img src="/2021/10/22/GetX%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/4.jpg"><br> <br>即可完成多语言的切换</p>
<p>最终效果如下<br><img src="/2021/10/22/GetX%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/5.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>IndirectCommandBuffer</title>
    <url>/2022/09/19/IndirectCommandBuffer/</url>
    <content><![CDATA[<p>今天学习了 IndirectCommandBuffer（ICB），它的功能就是将 GPU 相关的执行和输入数据进行打包后复用，可以节省占比比较高的分配、回收，指令编译等时间。</p>
<p>在使用 Metal 控制 GPU 进行操作的过程中，每当 GPU 执行完一组绘制指令，它便会将 CommandBuffer 丢弃掉，在需要绘制比较固定的内容（例如游戏中的 HUD）的场景下，效率就有些低，这个时候就可以使用 ICB，将常用的绘制指令进行“打包“并“缓存”，使用的时候只需要一些简单的调用即可</p>
<p><a href="https://developer.apple.com/documentation/metal/indirect_command_encoding/encoding_indirect_command_buffers_on_the_cpu">文档地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>Mapkit 使用自定义地图</title>
    <url>/2016/02/14/Mapkit-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<p>先了解什么是瓦片地图<br>如图所示<br><img src="/2016/02/14/Mapkit-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%B0%E5%9B%BE/1.jpg"></p>
<p>将地图切个为同样大小的瓦片，并进行分层，例如：<br>0层的地图只有一张瓦片，内容是整个世界地图<br>1层的地图将上一层的瓦片进行分割，每个瓦片分割为4个瓦片，并重新渲染成 256x256 分辨率的图片，最终得到 4 张瓦片，放在一起拼接成整个世界地图<br>3层的地图将上一层的瓦片继续进行分割，每个瓦片分割为4个瓦片，并重新渲染成 256x256 分辨率的图片，最终得到16张瓦片，放在一起可以拼接成整个世界地图<br>后续层级以此类推。这样，就可以通过xyz 坐标定位到某个层级的某个瓦片，并且可以将经纬度信息与瓦片关联起来</p>
<p>Google 地图瓦片地址 <a href="https://gac-geo.googlecnapps.cn/maps/vt?lyrs=m&x=%7Bx%7D&y=%7By%7D&z=%7Bz%7D&scale=%7Bscale%7D">https://gac-geo.googlecnapps.cn/maps/vt?lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}&amp;scale={scale}</a><br>其中 xyz 代表了瓦片坐标，scale 代表了瓦片的缩放倍率，浮点可选参数，范围0.125~4.0，默认为1，返回 256x256 分辨率的图片</p>
<p>相关类 MKTileOverlay，MKTileOverlayRenderer<br>代码如下</p>
<pre><code class="swift">class MapKitVC: UIViewController &#123;
    let map_view: MKMapView = MKMapView()
    let overlay = MKTileOverlay(urlTemplate: &quot;https://gac-geo.googlecnapps.cn/maps/vt?lyrs=m&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;scale=&#123;scale&#125;&quot;)
    
    override func viewDidLoad() &#123;
        super.viewDidLoad()
        self.view.backgroundColor = .white
        
        self.map_view.frame = self.view.bounds
        self.map_view.delegate = self
        self.map_view.preferredConfiguration = MKImageryMapConfiguration()
        self.view.addSubview(self.map_view)
        
        self.overlay.canReplaceMapContent = true
        self.map_view.addOverlay(overlay, level: .aboveRoads)
    &#125;
&#125;

extension MapKitVC: MKMapViewDelegate &#123;
    func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123;
        let render = MKTileOverlayRenderer(overlay: overlay)
        return render
    &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Metal 处理图片与渲染图片</title>
    <url>/2022/08/02/Metal-%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E4%B8%8E%E6%B8%B2%E6%9F%93%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>在 Metal 中，一个 RenderPass 代表了一个渲染命令组成的序列，可以通过创建两个不同的 RenderPass 来实现：一个 RenderPass 将图片经过处理后渲染到一个 Texture 中，另外一个将它渲染到屏幕上进行显示。</p>
<p>以一个例子来展示，我们将从本地读取一张图片，将其灰度化后，显示在 App 上。<br>原图与处理后的图片<br><img src="/2022/08/02/Metal-%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E4%B8%8E%E6%B8%B2%E6%9F%93%E5%9B%BE%E7%89%87/1.jpg"><br><img src="/2022/08/02/Metal-%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E4%B8%8E%E6%B8%B2%E6%9F%93%E5%9B%BE%E7%89%87/2.jpg"></p>
<p>创建一个 Mac App，然后拉一个 NSView 到 ViewController 中，然后把它的类型设置为 MTKView。接下来：</p>
<h2 id="第一步，读取原始图片数据"><a href="#第一步，读取原始图片数据" class="headerlink" title="第一步，读取原始图片数据"></a>第一步，读取原始图片数据</h2><pre><code class="swift">let path = Bundle.main.path(forResource: &quot;1&quot;, ofType: &quot;jpg&quot;)!
let url = URL(fileURLWithPath: path)
let data = try! Data(contentsOf: url)
let image = NSImage(data: data)!
cgImage = image.cgImage(forProposedRect: nil, context: nil, hints: nil)!
imageData = cgImage.dataProvider!.data! as NSData
</code></pre>
<p>与 iOS 不同，macOS 需要使用别的 API 获取 CGImage 对象</p>
<h2 id="第二步，创建-ImageTexture-存放原始图片数据"><a href="#第二步，创建-ImageTexture-存放原始图片数据" class="headerlink" title="第二步，创建 ImageTexture 存放原始图片数据"></a>第二步，创建 ImageTexture 存放原始图片数据</h2><pre><code class="swift">let descriptor = MTLTextureDescriptor()
descriptor.textureType = .type2D
descriptor.width = cgImage.width
descriptor.height = cgImage.height
descriptor.pixelFormat = .rgba8Unorm
descriptor.usage = [.shaderRead]
imageTexture = device.makeTexture(descriptor: descriptor)
        
/// 写入图片数据
let region = MTLRegionMake2D(0, 0, cgImage.width, cgImage.height)
imageTexture.replace(region: region, mipmapLevel: 0, withBytes: imageData.bytes, bytesPerRow: cgImage.bytesPerRow)
</code></pre>
<p>代码比较简单，通过创建 MTLTextureDescriptor，来创建 MTLTexture 对象</p>
<h2 id="第三步，创建-Offscreen-Texture，它是用来保存处理后的图片数据"><a href="#第三步，创建-Offscreen-Texture，它是用来保存处理后的图片数据" class="headerlink" title="第三步，创建 Offscreen Texture，它是用来保存处理后的图片数据"></a>第三步，创建 Offscreen Texture，它是用来保存处理后的图片数据</h2><pre><code class="swift">let descriptor = MTLTextureDescriptor()
descriptor.textureType = .type2D
descriptor.width = imageTexture.width
descriptor.height = imageTexture.height
descriptor.pixelFormat = imageTexture.pixelFormat
descriptor.usage = [.renderTarget, .shaderRead]
offscreenTexture = device.makeTexture(descriptor: descriptor)
</code></pre>
<p>需要注意的是，这个 texture 的 usage 比上一个多了 renderTarget，表示它是一个渲染目标，用来存放渲染的结果，准确设置 usage 可以提高性能，因为系统可以根据你设置的 usage 来优化内存。</p>
<h2 id="第四部，创建-Offscreen-Render-Pipeline，用于离屏渲染，处理原始图片"><a href="#第四部，创建-Offscreen-Render-Pipeline，用于离屏渲染，处理原始图片" class="headerlink" title="第四部，创建 Offscreen Render Pipeline，用于离屏渲染，处理原始图片"></a>第四部，创建 Offscreen Render Pipeline，用于离屏渲染，处理原始图片</h2><pre><code class="swift">let library = device.makeDefaultLibrary()!
let descriptor = MTLRenderPipelineDescriptor()
descriptor.vertexFunction = library.makeFunction(name: &quot;offscreenVertexShader&quot;)!
descriptor.fragmentFunction = library.makeFunction(name: &quot;offscreenFragmentShader&quot;)!
descriptor.colorAttachments[0].pixelFormat = offscreenTexture.pixelFormat
offscreenPipeline = try! device.makeRenderPipelineState(descriptor: descriptor)
</code></pre>
<p>同样，通过 XXXDescriptor 来创建 XXX，Descriptor 相当于一个配置类，这里传入了渲染所需的着色器程序，同时指定了渲染结果的像素值排列方式，由于这里会将处理后的图片数据渲染到 Texture 中，所以保持与 Texture 的 pixelFormat 一致。</p>
<h2 id="第五步，将图片渲染到-Offscreen-Texture-中"><a href="#第五步，将图片渲染到-Offscreen-Texture-中" class="headerlink" title="第五步，将图片渲染到 Offscreen Texture 中"></a>第五步，将图片渲染到 Offscreen Texture 中</h2><pre><code class="swift">let commandBuffer = commandQueue.makeCommandBuffer()!
        
let descriptor = MTLRenderPassDescriptor()
descriptor.colorAttachments[0].texture = offscreenTexture
descriptor.colorAttachments[0].clearColor = MTLClearColorMake(0, 0.1, 0, 1)
descriptor.colorAttachments[0].storeAction = .store
descriptor.colorAttachments[0].loadAction = .load
let commandEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: descriptor)!
        
let vertices = [
    Vertex(position: vector_float2(x:-1, y: 1), coordinate: vector_float2(x: 0, y: 0)),
    Vertex(position: vector_float2(x:-1, y:-1), coordinate: vector_float2(x: 0, y: 1)),
    Vertex(position: vector_float2(x: 1, y:-1), coordinate: vector_float2(x: 1, y: 1)),
    
    Vertex(position: vector_float2(x:-1, y: 1), coordinate: vector_float2(x: 0, y: 0)),
    Vertex(position: vector_float2(x: 1, y: 1), coordinate: vector_float2(x: 1, y: 0)),
    Vertex(position: vector_float2(x: 1, y:-1), coordinate: vector_float2(x: 1, y: 1)),
]
        
commandEncoder.setRenderPipelineState(offscreenPipeline)
commandEncoder.setVertexBytes(vertices, length: MemoryLayout&lt;Vertex&gt;.size * 6, index: 0)
commandEncoder.setFragmentTexture(imageTexture, index: 0)
commandEncoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 6)
commandEncoder.endEncoding()
        
commandBuffer.commit()
commandBuffer.waitUntilCompleted()
</code></pre>
<p>比较容易理解，首先配置 RenderPass 的一些行为，RenderPass 可以理解为某个渲染指令序列。然后创建顶点数组，这里可以直接使用结构体，接着就是配置 Pipeline、定点数据、纹理数据、绘制指令等，最后将命令提交到 GPU 执行，执行完成后我们就已经有相应的灰度图数据了。</p>
<h2 id="第六步，将-Offscreen-Texture-中保存的图片渲染到屏幕上。"><a href="#第六步，将-Offscreen-Texture-中保存的图片渲染到屏幕上。" class="headerlink" title="第六步，将 Offscreen Texture 中保存的图片渲染到屏幕上。"></a>第六步，将 Offscreen Texture 中保存的图片渲染到屏幕上。</h2><pre><code class="swift">func configOnscreenPipeline() -&gt; Void &#123;
    let library = device.makeDefaultLibrary()!
    let descriptor = MTLRenderPipelineDescriptor()
    descriptor.vertexFunction = library.makeFunction(name: &quot;onscreenVertexShader&quot;)!
    descriptor.fragmentFunction = library.makeFunction(name: &quot;onscreenFragmentShader&quot;)!
    descriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat
    onscreenPipeline = try! device.makeRenderPipelineState(descriptor: descriptor)
&#125;
    
func mtkViewRender() -&gt; Void &#123;
    let vertices = [
        Vertex(position: vector_float2(x:-960, y: 540), coordinate: vector_float2(x: 0, y: 0)),
        Vertex(position: vector_float2(x:-960, y:-540), coordinate: vector_float2(x: 0, y: 1)),
        Vertex(position: vector_float2(x: 960, y:-540), coordinate: vector_float2(x: 1, y: 1)),
            
        Vertex(position: vector_float2(x:-960, y: 540), coordinate: vector_float2(x: 0, y: 0)),
        Vertex(position: vector_float2(x: 960, y: 540), coordinate: vector_float2(x: 1, y: 0)),
        Vertex(position: vector_float2(x: 960, y:-540), coordinate: vector_float2(x: 1, y: 1)),
    ]
        
    let commandBuffer = commandQueue.makeCommandBuffer()!
    let commandEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: mtkView.currentRenderPassDescriptor!)!
        
    commandEncoder.setRenderPipelineState(onscreenPipeline)
    commandEncoder.setViewport(MTLViewport(originX: 0, originY: 0, width: Double(viewport.x), height: Double(viewport.y), znear: 0, zfar: 1))
    commandEncoder.setVertexBytes(vertices, length: MemoryLayout&lt;Vertex&gt;.size * 6, index: 0)
    commandEncoder.setVertexBytes(&amp;viewport, length: MemoryLayout&lt;vector_float2&gt;.size, index: 1)
    commandEncoder.setFragmentTexture(offscreenTexture, index: 0)
    commandEncoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 6)
    commandEncoder.endEncoding()
        
    commandBuffer.present(mtkView.currentDrawable!)
    commandBuffer.commit()
&#125;
</code></pre>
<p>将保存了灰度图数据的纹理渲染到屏幕上，具体可以参考<a href="https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives">苹果官方文档</a>，讲解的比较详细</p>
<p>通过离屏渲染，可以现将图片进行处理，假如遮罩等等，由于 fragment 支持传入多个纹理，所以可以处理多个图层的情况，渲染的结果既可以通过 MTKView 等方式直接显示在屏幕上，也可以保存为图片文件，或者是其他的用途，可以进一步的挖掘一下。</p>
]]></content>
  </entry>
  <entry>
    <title>Metal 三角形绘制</title>
    <url>/2022/07/19/Metal-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<p>今天按照自己的想法吧三角形的绘制重新改了下，Metal 传递顶点数据方便太多（也可能是 OpenGL 学艺不精？），可以直接定义一个包含了位置信息与颜色信息的结构体，将整个结构体传入就可以了，而且 Metal 的 shader 语法是 C++ 的一个变体，里面很多东西都是相通的。</p>
<p>不同于 OpenGL 中的 vertex shade，我们通过在 shader 中给 glPosition 赋值来告诉 GPU 顶点数据，Metal 还可以通过 [[position]] 修饰符来告诉 GPU 顶点数据。</p>
<p>我目前所学到的，有两种方法来设置顶点信息，一种是直接返回顶点信息，例如</p>
<pre><code class="c++">vertex vector_float4 vertexShader(
                                  uint vertexID [[vertex_id]],
                                  device const vector_float2* vertices [[buffer(0)]],
                                  device const vector_float2* viewport [[buffer(1)]]
                                  )
&#123;
    vector_float4 out = vector_float4(0, 0, 0, 1);
    vector_float2 viewportSize = vector_float2(*viewport);

    out.position.xy = vertices[vertexID].xy / (viewportSize / 2);
    return out;
&#125;
</code></pre>
<p>但是这样会有一个问题，fragment 中的颜色信息没办法传进去，虽然可以使用 commandEncoder.setFragmanetBuffer 方法来给 fragment 函数传入相关参数，但是看了下 MSL（Metal Shading Language） 的文档，没有一个类似于 [[vertex_id]] 的修饰符来为每一个顶点生成一个索引，没有办法确定我该用数据中的哪一个元素作为定点到的颜色值。(可能是还没学到，毕竟纹理部分还没学到)</p>
<p>另一种方式是使用结构体，非常方便！</p>
<pre><code class="c++">vertex RasterizeData vertexShader(
                                  uint vertexID [[vertex_id]],
                                  device const vector_float2* vertices [[buffer(0)]],
                                  device const vector_float3* fragments [[buffer(1)]],
                                  device const vector_float2* viewport [[buffer(2)]],
                                  device const VertexData* vertexDatas [[buffer(3)]]
                                  )
&#123;
    RasterizeData out;
    
    vector_float2 viewportSize = vector_float2(*viewport);
    
    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);
    out.position.xy = vertexDatas[vertexID].position / (viewportSize / 2);
    
    out.color = vector_float4(0.0, 0.0, 0.0, 1.0);
    out.color.xyz = vertexDatas[vertexID].color;
    
    return out;
&#125;

struct RasterizeData&#123;
    float4 position [[position]]; 
    float4 color;
&#125;;
</code></pre>
<p>通过定义这样一个结构体，并加上 [[position]] 修饰符来告诉 shader，这个属性里面的信息就是顶点数据，然后再 fragment shader 里，用 [[stage_in]] 修饰符来告诉 fragment shader，这个参数是 vertexShader 传进来的，来拿到颜色信息。</p>
<pre><code class="c++">fragment vector_float4 fragmentShader(RasterizeData in [[stage_in]])
&#123;
    return in.color;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Metal 学习结构图（简单版）</title>
    <url>/2022/07/14/Metal-%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9E%84%E5%9B%BE%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2022/07/14/Metal-%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9E%84%E5%9B%BE%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/1.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>Metal 开启深度测试</title>
    <url>/2022/08/10/Metal-%E5%BC%80%E5%90%AF%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>Metal默认的渲染方式是“画家模式”，即按照绘制的顺序来进行图像渲染，在绘制立方体的时候可能会出现画面层次错误的问题，这个时候就需要深度测试功能了，开启深度检测后，MTkView 会提供一个存储了深度信息的纹理供我们使用，每次绘制时，会将该处的Z值与深度纹理中对应的值进行比较后再决定是否绘制新的点。</p>
<p>依照这个机制，可以通过给纹理设置不同地深度值，来判断当前点击的是第几个纹理。需要注意的是，纹理的远点在左上角，macOS 的坐标原点在左下角，拿到当前点击的坐标后，还需要转换一下。</p>
<p>由于 Metal 对 Texture 中的数据做了某些处理，导致我们不能直接读取，需要通过 MTLBlitCommandEncoder 来通过指定某个区域，将这个区域内的数据复制出来后进行读取，核心代码如下</p>
<pre><code class="swift">let commandBuffer = commandQueue.makeCommandBuffer()!
        
let blitEncoder = commandBuffer.makeBlitCommandEncoder()!
let depthTexture = mtkView.depthStencilTexture!
// 先前指定了纹理的格式为 Float32，所以这里传入4
let buffer = device.makeBuffer(length: 4, options: .storageModeShared)!
let origin = MTLOriginMake(Int(touchPoint.x), Int(touchPoint.y), 0)
let size = MTLSizeMake(1, 1, 1)
blitEncoder.copy(from: depthTexture, sourceSlice: 0, sourceLevel: 0, sourceOrigin: origin, sourceSize: size, to: buffer, destinationOffset: 0, destinationBytesPerRow: 4, destinationBytesPerImage: 4)
blitEncoder.endEncoding()
        
commandBuffer.commit()
commandBuffer.waitUntilCompleted()

let depth = buffer.contents().advanced(by: 0).load(as: Float32.self)
print(depth)
</code></pre>
<p>完整的项目如下，绘制了两个不同深度的三角形，点击相应的地方会打印出当前点击位置的深度值</p>
<p><img src="/2022/08/10/Metal-%E5%BC%80%E5%90%AF%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/1.zip" alt="项目代码"></p>
]]></content>
  </entry>
  <entry>
    <title>Metal 画板</title>
    <url>/2022/10/28/Metal-%E7%94%BB%E6%9D%BF/</url>
    <content><![CDATA[<p>Metal 版画板已完成<br>原理比较简单，难点主要在于笔刷尺寸的计算以及缩放平移旋转的计算</p>
<p><img src="/2022/10/28/Metal-%E7%94%BB%E6%9D%BF/1.zip" alt="项目文件"></p>
]]></content>
  </entry>
  <entry>
    <title>Metal入门-使用GPU执行计算任务</title>
    <url>/2021/04/14/Metal%E5%85%A5%E9%97%A8-%E4%BD%BF%E7%94%A8GPU%E6%89%A7%E8%A1%8C%E8%AE%A1%E7%AE%97%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>这篇文档中，你会接触到如下协议</p>
<ul>
<li>Protocols</li>
<li>MTLDevice</li>
<li>MTLLibrary</li>
<li>MTLFunction </li>
<li>MTLComputePipelineState</li>
<li>MTLCommandQueue</li>
<li>MTLBuffer</li>
<li>MTLCommandBuffer</li>
<li>MTLComputeCommandEncoder</li>
</ul>
<h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><ul>
<li><strong>Pipeline</strong> - 管线（流水线），代表不需要人工干预的一个流程，其中包含多个步骤</li>
<li><strong>MSL（Metal Shading Language</strong>）- 编写着色器的语言</li>
<li><strong>Command Buffer</strong> - 指令缓冲区</li>
<li><strong>Command Queue</strong> - 指令队列，里面存放需要 GPU 执行的指令</li>
<li><strong>Shader</strong> - 着色器，相当于用于渲染的方法，这里指代 .metal 文件中的方法</li>
<li><strong>Compute Pass</strong> - 计算通道</li>
</ul>
<h3 id="层级关系图"><a href="#层级关系图" class="headerlink" title="层级关系图"></a>层级关系图</h3><p><img src="/2021/04/14/Metal%E5%85%A5%E9%97%A8-%E4%BD%BF%E7%94%A8GPU%E6%89%A7%E8%A1%8C%E8%AE%A1%E7%AE%97%E4%BB%BB%E5%8A%A1/1.png"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在这个例子中：</p>
<ul>
<li>你将学到所有的 Metal App 中都会用到的基本任务。</li>
<li>你将了解到如何将简单的 C 函数，转换为 Metal Shading Language（MSL）以便它能够在 GPU 上运行。</li>
<li>你会发现一个 GPU 对象，通过创建一个管线，将预备的的 MSL 函数放在 GPU 上运行，并且创建一个 GPU 可访问的数据对象。</li>
<li>要在管线上处理你的数据，创建一个指令缓冲区，将指令写入其中，提交指令缓冲区到指令队列中。Metal 将把这些指令发送到 GPU 去执行。<br>写一个 GPU 函数来执行计算<br>为了说明 GPU 编程，这个 App 将两个数组的各个元素相加，将结果写入到第三个数组中</li>
</ul>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>下图显示了一个在 CPU 上执行这个计算的 C 函数。</p>
<pre><code class="c">void add_arrays(const float* inA,
                const float* inB,
                float* result,
                int length)
&#123;    
    for (int index = 0; index &lt; length ; index++) &#123;
        result[index] = inA[index] + inB[index];
    &#125;
&#125;
</code></pre>
<p>数组中每一个元素都分别地计算，互不影响，所以可以很安全的使用并发来完成。</p>
<p>想要在 GPU 上执行些计算，你需要使用 Metal Shading Language（MSL）来重写这个函数。MSL 是 C++ 的一个变体，设计用于 GPU 编程。Metal 中，运行在 GPU 上的代码叫做着色器。由于以前在 GPU 上运行的代码刚开始是用来计算 3D 图形的颜色的，所以叫这个名字。</p>
<p>下图展示了一个用 MSL 编写的，执行和上图相同计算的着色器，示例工程在 add.metal 文件中定义了这个函数。 Xcode 会打包当前 Target 中所有的 .metal 文件并创建一个默认的 Metal Library ，在后面你会学到如何读取默认的 Metal Library。</p>
<pre><code class="c++">kernel void add_arrays(device const float* inA,
                       device const float* inB,
                       device float* result,
                       uint index [[thread_position_in_grid]])
&#123;
    // the for-loop is replaced with a collection of threads, each of which
    // calls this function.    
    result[index] = inA[index] + inB[index];
&#125;
</code></pre>
<p>上面两段代码很相似，但是 MSL 版本的有些重要的不同点，我们来仔细看看 MSL 版本的。</p>
<p>首先，函数声明加入了 kernel 关键字，它有两个作用：</p>
<ul>
<li>表明它是一个公开的函数（public GPU function），公开函数是你的 App 唯一能获取到的函数，公开函数不能被其他函数（着色器）调用</li>
<li>计算函数（也叫 compute kernel），它使用一组线程来完成平行计算。</li>
</ul>
<p>add_arrays 方法声明了三个带有 device 关键字的参数，表明这些参数的指针指向的是 device 内存空间。 MSL 定义了许多隔离开来的内存空间，当你在 MSL 声明一个指针的时候，你也必须提供一个关键字声明它的内存空间。使用 device 代表声明了一个持久化的空间供 GPU 读写。</p>
<p>MSL 同时也移除 for 循环，因为函数现在被计算矩阵中的许多线程调用，这个例子创建了一个和数组一样的一维矩阵，使得数组中的每一个实体都被不同的线程分别计算。</p>
<p>为了移除 for 循环中的下标，函数提供了一个新的下标参数，使用了 thread_position_in_grid 关键字来修饰，这个使用的是 C++ 的语法。这个关键告诉 Metal ，它应该为每一个线程指定一个唯一的下标并将它放到 index 参数中，因为 add_arrays 使用的是一维矩阵，所以 index 定义为一个数字标量。尽管 for 循环被移除了，上面两个函数仍然使用相同的语句来计算两个数字各个元素的和。</p>
<p>总结：如果你想将类似于上图的方法由 C 或 C++ 转换为 MSL，只需要移除 for 循环，并新增 index 参数即可。</p>
<h3 id="获取-GPU-对象"><a href="#获取-GPU-对象" class="headerlink" title="获取 GPU 对象"></a>获取 GPU 对象</h3><p>在 App 中，MTLDevice 抽象类代表了你的一个 GPU，你使用它来同 GPU 通信。Metal 为每一个 GPU 都创建了一个 MTLDevice 对象，你可以通过 MTLCreateSystemDefaultDevice() 方法来获取一个默认的 GPU，在 macOS 中，可能会有多个 GPU 的情况，Metal 会选择一个作为默认的 GPU 并将它返回给你。macOS 同时也提供了获取所有 GPU 对象的方法，但是这个例子只获取默认的。</p>
<pre><code class="Objective-C">id&lt;MTLDevice&gt; device = MTLCreateSystemDefaultDevice()
</code></pre>
<h3 id="初始化-Metal-相关的对象"><a href="#初始化-Metal-相关的对象" class="headerlink" title="初始化 Metal 相关的对象"></a>初始化 Metal 相关的对象</h3><p>Metal 描述了和 GPU 相关的实体，例如编译着色器（compiled shaders）、内存缓冲（memory buffers）、纹理（texture）。想要创建这些 GPU 相关的对象，可以通过调用 MTLDevice 的 api，或通过 MTLDevice 创建的对象的 api。所有直接或间接通过 MTLDevice 创建的对象仅用于这个设备，那些拥有多个 GPU 的机器，使用多个 MTLDevice 对象创建相似的对象树。</p>
<h3 id="获取-Metal-函数的引用"><a href="#获取-Metal-函数的引用" class="headerlink" title="获取 Metal 函数的引用"></a>获取 Metal 函数的引用</h3><p>首先，我们读取 add_arrays 函数并做好将它运行在 GPU 上的准备。当编译 App 时，Xcode 会编译 add_arrays 函数并将它添加到默认的 Metal 库（MTLLibrary）中，这个 Metal 库（MTLLibrary）会嵌入到 App 里。你可以使用 MTLLibrary 和 MTLFunction 对象获取关于 Metal 库 和库里面的函数的信息。为了获取 add_arrays 函数对应的对象，你需要通过 MTLDevice 对象创建一个默认 Metal 库，然后通过这个库获取对应的函数（MTLFunction）。</p>
<pre><code class="Objective-C">/// 获取 Shader 集合
id&lt;MTLLibrary&gt; library = [device newDefaultLibrary];
   
/// 获取对应的 Shader
id&lt;MTLFunction&gt; add = [library newFunctionWithName:@&quot;add_arrays&quot;];
</code></pre>
<h3 id="准备-Metal-流水线（渲染管线）"><a href="#准备-Metal-流水线（渲染管线）" class="headerlink" title="准备 Metal 流水线（渲染管线）"></a>准备 Metal 流水线（渲染管线）</h3><p>函数对象（MTLFunction）并不包含具体的执行代码，他只是 MSL function 的一个代理，通过创建一个流水线（Pipeline），你可以将它转换为具体的可执行代码。一个流水线（Pipeline）定义了一组操作，这些操作合起来即可完成某个任务（计算、渲染等）。在 Metal 中，Pipeline State Object 对象代表了一个流水线，本例主要使用了一个计算函数，所以使用 MTLComputePipelineState 对象。</p>
<pre><code class="Objective-C">/// 创建执行某个 Shader 的工作流，这里是 times，即两数组元素相乘（用于计算的渲染管线）
id&lt;MTLComputePipelineState&gt; pipeline = [device newComputePipelineStateWithFunction:add error:nil];
</code></pre>
<p>一个计算流水线执行单个计算函数，且可选择在执行之前对输入数据进行操作，或在执行完成后对输出结果进行操作。<br>当你创建了一个 Pipeline State Object 时，MTLDevice 已经完成了对该函数的编译（即 add 函数对象），通过它生成了对应 GPU 能够执行的代码。本例同步创建 Pipeline State Object 并直接将它返回给 App。因为并以需要一点时间，所以避免在性能敏感的地方同步创建 Pipeline State Object 对象。<br>注意：目前你看到的所有的 Metal 返回的对象，他们都没有具体的类，只是遵循了某一个协议。Metal 使用协议将对 GPU 操作抽象化，因为操作不同的 GPU 的方法可能存在巨大的差异，通过这个可以很好地隐藏他们。</p>
<h3 id="创建一个-Command-Queue"><a href="#创建一个-Command-Queue" class="headerlink" title="创建一个 Command Queue"></a>创建一个 Command Queue</h3><p>要将任务发送到 GPU，你需要一个命令队列（Command Queue）。Metal 使用命令队列来安排命令。可以通过 MTLDevice 来创建一个队列。</p>
<pre><code class="Objective-C">/// 命令队列
id&lt;MTLCommandQueue&gt; queue = [device newCommandQueue];
</code></pre>
<h3 id="创建-Data-Buffers-与读取数据"><a href="#创建-Data-Buffers-与读取数据" class="headerlink" title="创建 Data Buffers 与读取数据"></a>创建 Data Buffers 与读取数据</h3><p>在初始化完成基本的 Metal 对象后（MTLDevice，MTLLibrary，MTLFunction，MTLComputePipelineState 和 MTLCommandQueue），开始读取需要处理的数据。这个任务性能消耗很小，但是尽早创建仍然是有用的。<br>GPU 拥有它自己的内存空间，也可以和操作系统共享部分内存。 Metal 和操作系统内核都需要执行额外的工作让你保存数据到内存和是 GPU 能够访问到该部分内存。 Metal 使用资源对象（MTLResource）将这一过程抽象化了。一个资源对象代表了一段已分配的内存，这段内存在 GPU 执行指令的时候是可以访问的，可以使用 MTLDevice 的 api 来创建它。<br>例子中创建了三个缓冲器（MTLBuffer），将作为参数的两个数组中的数据填入前两个，第三个则用来接收计算结果。</p>
<pre><code class="Objective-C">/// 创建对象传递参数 与 接收计算结果，length 为字节数
id&lt;MTLBuffer&gt; bufferA = [device newBufferWithLength:5 options:MTLResourceStorageModeShared];
id&lt;MTLBuffer&gt; bufferB = [device newBufferWithLength:5 options:MTLResourceStorageModeShared];
id&lt;MTLBuffer&gt; bufferC = [device newBufferWithLength:5 options:MTLResourceStorageModeShared];
   
/// 填入数据
[self fillList:bufferA length:5 start:10];
[self fillList:bufferB length:5 start:0];
</code></pre>
<p>本例中的资源即 MTLBuffer 对象，它是一段已分配的内存，与类型无关的，Metal 将它视作一段字节数据，然而，在着色器中，你指定了参数的类型，这就是说，你往 buffer 中填入的数据类型必须要和着色器中对应的参数类型一致。</p>
<p>当你创建 buffer 时，需要提供一个字段，用来决定它的部分性能特性以及 CPU 与 GPU 是否可以访问它的内容。例子中使用了 MTLResourceStorageModeShared，代表 CPU 和 GPU 均可以访问它的内容。<br>下面是例子中向 buffer 中填入数据的方法</p>
<pre><code class="Objective-C">- (void)fillList:(id&lt;MTLBuffer&gt;)buffer length:(int)length start:(int)start &#123;
  Byte* bytes = (Byte*)buffer.contents;
  for (NSInteger i = 0; i &lt; length; i++) &#123;
    bytes[i] = i + start;
  &#125;
&#125;
</code></pre>
<h3 id="创建-Command-Buffer"><a href="#创建-Command-Buffer" class="headerlink" title="创建 Command Buffer"></a>创建 Command Buffer</h3><p>通过Command Queue（命令队列）来创建 Command Buffer 对象</p>
<pre><code class="Objective-C">/// 创建 Buffer 与 Encoder
/// 通过 Encoder 将数据写入到 buffer 中，再提交到 queue 中，最终交于 GPU 执行
id&lt;MTLCommandBuffer&gt; commandBuffer = [queue commandBuffer];
</code></pre>
<h3 id="创建-Command-Encoder"><a href="#创建-Command-Encoder" class="headerlink" title="创建 Command Encoder"></a>创建 Command Encoder</h3><p>要将命令写入 Command Buffer 中，你使用一个 Command Encoder（命令编码）对象，用来编码特定的任务。本例中创建了一个 Compute Command Encoder，它可以执行一个 comput pass。一个 compute pass 它有一系列的指令，这些指令可以执行 compute pipeline（计算管线）。每一个计算指令都使 GPU 创建一个线程网来执行对应的命令。</p>
<pre><code class="Objective-C">id&lt;MTLComputeCommandEncoder&gt; commandEncoder = [commandBuffer computeCommandEncoder];
</code></pre>
<h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><p>要编码一条指令，你需要调用 encoder 的一系列方法。有些方法用来设置状态信息，例如 Pipeline State Object 或 需要传递给管线的参数信息。当你完成了这些后，你可以编码指令以执行管线。encoder 对象会将所有的状态的改变和指令参数写入 Command Buffer 中。</p>
<h3 id="设置管线与参数数据"><a href="#设置管线与参数数据" class="headerlink" title="设置管线与参数数据"></a>设置管线与参数数据</h3><p>首先设置需要执行指令的 Pipeline State Object（管线对象）。然后为每一个 pipeline 需要的传递给 add_arrays Shader （着色器）的参数设置数据。对于这个 pipeline，需要使用三个 MTLBuffer 对象来传递参数。Metal 自动为 add_arrays 的参数添加索引，从 0 开始，所以你需要将参数设置到正确的位置。</p>
<pre><code class="Objective-C">/// 我想要 GPU 执行哪一个工作流（目前是计算）
[commandEncoder setComputePipelineState:pipeline];
/// 传入参数，根据下标，填入 Shader 中参数列表中对应的位置
[commandEncoder setBuffer:bufferA offset:0 atIndex:0];
[commandEncoder setBuffer:bufferB offset:0 atIndex:1];
[commandEncoder setBuffer:bufferC offset:0 atIndex:2];
</code></pre>
<p>你也可以为每个参数指定一个偏移量，0 代表从 buffer 的起始处获取数据，这样你就可以将所有的数据放到一个 buffer 中去了，然后通过偏移量来标志不同的参数位置。</p>
<p>你不需要指定 index 参数，因为 add_arrays 指定了该参数由 GPU 提供。</p>
<h3 id="指定线程数和结构"><a href="#指定线程数和结构" class="headerlink" title="指定线程数和结构"></a>指定线程数和结构</h3><p>接下来，决定创建多少线程与如何规划它们。Metal 能够创建一维，二维或三维栅格。add_arrays 这个函数使用了一维的数组，如此例子中便创建一个一维的栅格，它的大小是 dataSize x 1 x 1，内容是从 0 到 dataSize - 1。</p>
<pre><code class="Objective-C">MTLSize gridSize = MTLSizeMake(5, 1, 1);
</code></pre>
<h3 id="指定线程组大小"><a href="#指定线程组大小" class="headerlink" title="指定线程组大小"></a>指定线程组大小</h3><p>Metal 将栅格再分割为更小的栅格组，称作 threadgroups。每一个 threadgroups 可以单独地进行计算。Metal 能够将 threadgroups 发送给 GPU 上不同的处理部分从而提高处理速度。此外，你需要基于你的指令决定 threadgroups 的大小。</p>
<pre><code class="Objective-C">  /// Metal 将计算栅格分成了一个个的小的栅格，称作 threadgroups，每一个 threadgroups 都可以独立计算
  /// Metal 将 threadgroups 分配给不同的计算任务从而提高计算速度
  NSUInteger threadGroupSize = pipeline.maxTotalThreadsPerThreadgroup;
  if (threadGroupSize &gt; 5) &#123;
    threadGroupSize = 5;
  &#125;
  MTLSize threadSize = MTLSizeMake(threadGroupSize, 1, 1);
</code></pre>
<p>本例向 Pipeline State Object 请求最大的 threadgroups 并在它大于数据长度的情况下将其缩减到适合数据长度的大小。maxTotalThreadsPerThreadgroup 这个属性提供了当前 threadgroup 中允许的最大线程数量，这个数量与创建 Pipeline State Object 的函数的复杂程度有关。</p>
<p>编码计算命令并发送到执行线程</p>
<p>最后，编码指令并发送到线程栅格中。</p>
<pre><code class="Objective-C">[commandEncoder dispatchThreads:gridSize threadsPerThreadgroup:threadSize];
</code></pre>
<p>当 GPU 执行这个指令时，它会使用你先前设置的 Pipeline State 以及指令的参数发送到各个线程中去执行计算。<br>你能够遵照相同的步骤来使用这个 encoder，从而编码多个计算指令。例如，你可以只需要设置 Pipeline State Object 一次，然后对于每一个需要处理的 buffer ，设置新的参数并编码。</p>
<h3 id="结束-Encoding"><a href="#结束-Encoding" class="headerlink" title="结束 Encoding"></a>结束 Encoding</h3><p>让你不需要添加更多的计算流程时，你可以结束 encoder 编码。</p>
<pre><code class="Objective-C">  /// 编码结束
  [commandEncoder endEncoding];
</code></pre>
<h3 id="提交-Command-Buffer-以执行命令"><a href="#提交-Command-Buffer-以执行命令" class="headerlink" title="提交 Command Buffer 以执行命令"></a>提交 Command Buffer 以执行命令</h3><p>通过提交 Command Buffer 到 CommandQueue 中去以执行 Command Buffer 中的指令。</p>
<pre><code class="Objective-C">  /// 提交命令到 CommandQueue 发给 GPU 开始进行计算
  [commandBuffer commit];
</code></pre>
<p>Command Queue 创建了 Command Buffer，所以提交 Command Buffer 始终会将它放到该队列上。在你提交了 Command Buffer 后，Metal 异步地准备指令以供执行，然后安排 Command Buffer 在 GPU 上执行，在 GPU 执行完 Command Buffer 中的所有指令后，Metal 会将该 Command Buffer 标记为已完成。</p>
<h3 id="等待命令执行完成"><a href="#等待命令执行完成" class="headerlink" title="等待命令执行完成"></a>等待命令执行完成</h3><p>你的 App 能够在 GPU 执行指令的时候做其他的事情。但是例子中并不需要做其他的工作，所以它就是简单地等待 Command Buffer 执行完毕。</p>
<pre><code class="Objective-C">  /// 这里直接等待，直到计算完成
  [commandBuffer waitUntilCompleted];
</code></pre>
<p>或者，等待 Metal 处理完所有的指令后，通过 addCompletehandler 方法添加一个完成回调，或者检查 Command Buffer 的 status 属性的状态。</p>
<h3 id="从-Buffer-中读取结果"><a href="#从-Buffer-中读取结果" class="headerlink" title="从 Buffer 中读取结果"></a>从 Buffer 中读取结果</h3><p>在 Command Buffer 执行完毕后，GPU 的计算结果存储在输出 buffer 中，Metal 做了所有必要的步骤保证 CPU 可以读取它们。在实际的 App 中，你可以从这个 buffer 中读取内容以及对他们做一些事情，例如在屏幕上显示它们或者将它们写入到文件中。由于例子里的计算结果仅用于解释创建 Metal App 的过程。例子里读取输出 buffer 里的值并测试以确保 CPU 和 GPU 计算出同样的结果。</p>
<p>完整例子</p>
<pre><code class="Objective-C">/// 获取 GPU 设备
id&lt;MTLDevice&gt; device = MTLCreateSystemDefaultDevice();
 
/// 获取 Shader 集合
id&lt;MTLLibrary&gt; library = [device newDefaultLibrary];
 
/// 获取对应的 Shader
id&lt;MTLFunction&gt; add = [library newFunctionWithName:@&quot;add_arrays&quot;];
 
/// 创建执行某个 Shader 的工作流，这里是 times，即两数组元素相乘（用于计算的渲染管线）
id&lt;MTLComputePipelineState&gt; pipeline = [devicenewComputePipelineStateWithFunction:add error:nil];
 
/// 命令队列
id&lt;MTLCommandQueue&gt; queue = [device newCommandQueue];
 
/// 创建对象传递参数 与 接收计算结果，length 为字节数
id&lt;MTLBuffer&gt; bufferA = [device newBufferWithLength:5options:MTLResourceStorageModeShared];
id&lt;MTLBuffer&gt; bufferB = [device newBufferWithLength:5options:MTLResourceStorageModeShared];
id&lt;MTLBuffer&gt; bufferC = [device newBufferWithLength:5options:MTLResourceStorageModeShared];
 
/// 填入数据
[self fillList:bufferA length:5 start:10];
[self fillList:bufferB length:5 start:0];
   
/// 创建 Buffer 与 Encoder
/// 通过 Encoder 将数据写入到 buffer 中，再提交到 queue 中，最终交于 GPU 执行
id&lt;MTLCommandBuffer&gt; commandBuffer = [queue commandBuffer];
id&lt;MTLComputeCommandEncoder&gt; commandEncoder = [commandBuffer computeCommandEncoder];
 
/// 我想要 GPU 执行哪一个工作流（目前是计算）
[commandEncoder setComputePipelineState:pipeline];
/// 传入参数，根据下标，填入 Shader 中参数列表中对应的位置
[commandEncoder setBuffer:bufferA offset:0 atIndex:0];
[commandEncoder setBuffer:bufferB offset:0 atIndex:1];
[commandEncoder setBuffer:bufferC offset:0 atIndex:2];
 
/// 设置计算单元矩阵大小，这里是一位数组，且里面只有5个元素，所以矩阵大小为 5x1x1
MTLSize gridSize = MTLSizeMake(5, 1, 1);
 
/// Metal 将计算栅格分成了一个个的小的栅格，称作 threadgroups，每一个 threadgroups 都可以独立计算
/// Metal 将 threadgroups 分配给不同的计算任务从而提高计算速度
NSUInteger threadGroupSize = pipeline.maxTotalThreadsPerThreadgroup;
if (threadGroupSize &gt; 5) &#123;
  threadGroupSize = 5;
&#125;
MTLSize threadSize = MTLSizeMake(threadGroupSize, 1, 1);
[commandEncoder dispatchThreads:gridSize threadsPerThreadgroup:threadSize];
/// 编码结束
[commandEncoder endEncoding];
/// 提交命令到 CommandQueue 发给 GPU 开始进行计算
[commandBuffer commit];
/// 这里直接等待，直到计算完成
[commandBuffer waitUntilCompleted];
[self printBuffer:bufferC];
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>NAT协议</title>
    <url>/2017/11/12/NAT%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>NAT(Network Address Translation)，网络地址转换协议</p>
<h2 id="NAT四种模式"><a href="#NAT四种模式" class="headerlink" title="NAT四种模式"></a>NAT四种模式</h2><p>Full Cone<br>Address Restricted Cone<br>Port Restricted Cone<br>Symmetric</p>
<h3 id="Full-Core"><a href="#Full-Core" class="headerlink" title="Full Core"></a>Full Core</h3><p>这种模式NAT内部的机器A连接过外网机器C后，NAT会打开一个端口。然后外网的任何发到这个打开的端口的UDP数据报都可以到达A。不管是不是C发过来的。</p>
<h3 id="Address-Restricted-Cone"><a href="#Address-Restricted-Cone" class="headerlink" title="Address Restricted Cone"></a>Address Restricted Cone</h3><p>这种NAT内部的机器A连接过外网的机器C后，NAT打开一个端口。然后C可以用任何端口和A通信，其他的外网机器不行。</p>
<h3 id="Port-Restricted-Cone"><a href="#Port-Restricted-Cone" class="headerlink" title="Port Restricted Cone"></a>Port Restricted Cone</h3><p>这种NAT内部的机器A连接过外网的机器C后，NAT打开一个端口。然后C可以用原来的端口和A通信，其他的外网机器不行。</p>
<h3 id="Symmetric"><a href="#Symmetric" class="headerlink" title="Symmetric"></a>Symmetric</h3><p>与 Port Restricted Cone 类似，但是对每一个内部机器A访问的外网机器B，都会生成一个新的外部端口号，形成 内部IP和Port 与 NAT IP和端口 形成一对多的关系</p>
<h2 id="NAT类型检测"><a href="#NAT类型检测" class="headerlink" title="NAT类型检测"></a>NAT类型检测</h2><p>使用STUN服务器，该服务器需要有两个公网IP，IP1:Port 和 IP2:Port</p>
<ol>
<li>Client -&gt; IP1:Port, Server 使用 IP1:Port 将收到的请求源IP:Port -&gt; Client，如果一致，则无NAT，否则进入下一步</li>
<li>Client -&gt; IP1:Port, Server 使用 IP2:Port -&gt; Client, 如果 Client 收到回复，则为 Full Cone NAT，否则进入下一步</li>
<li>Client -&gt; IP2:Port, Server 使用 IP2:Port 将收到的源 IP:Port -&gt; Client, Client 将该 Port 与第1步收到的 Port 对比，如果不一致，则为 Symmetric NAT，否则进入下一步</li>
<li>Client -&gt; IP2:Port, 要求 Server 使用该IP的另一个端口回答，Server 回复后，如果 Client 收到回答，则为 Address Restricted Cone NAT，否则为 Port Restricted Cone NAT</li>
</ol>
<h2 id="穿透表"><a href="#穿透表" class="headerlink" title="穿透表"></a>穿透表</h2><table>
<thead>
<tr>
<th align="center">A客户端NAT类型</th>
<th align="center">B客户端NAT类型</th>
<th align="center">能否穿透</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全锥</td>
<td align="center">任何类型</td>
<td align="center">能打通</td>
</tr>
<tr>
<td align="center">地址受限制</td>
<td align="center">地址受限制&#x2F;端口受限制&#x2F;对称型</td>
<td align="center">能打通</td>
</tr>
<tr>
<td align="center">端口受限制</td>
<td align="center">端口受限制</td>
<td align="center">能打通</td>
</tr>
<tr>
<td align="center">端口限制</td>
<td align="center">对称型</td>
<td align="center">不能打通</td>
</tr>
<tr>
<td align="center">对称型</td>
<td align="center">对称型</td>
<td align="center">不能打通</td>
</tr>
</tbody></table>
<p>UDP打洞<br><img src="/2017/11/12/NAT%E5%8D%8F%E8%AE%AE/1.png"></p>
<ol>
<li>ClientA请求Server。</li>
<li>ClientB请求Server。</li>
<li>Server把ClientA的IP和端口信息发给ClientB。</li>
<li>Server把ClientB的IP和端口信息发给ClientA。</li>
<li>ClientA利用信息给ClientB发消息。（A信任B）</li>
<li>ClinetB利用信息给ClientA发消息。（B信任A）</li>
<li>连接已经建立。两者可以直接通信了。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Swift基本操作符</title>
    <url>/2018/07/27/Swift%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h3 id="Basic-Operators-（基本操作符）"><a href="#Basic-Operators-（基本操作符）" class="headerlink" title="Basic Operators （基本操作符）"></a>Basic Operators （基本操作符）</h3><h5 id="Terminology-（术语）"><a href="#Terminology-（术语）" class="headerlink" title="Terminology （术语）"></a>Terminology （术语）</h5><ul>
<li>Unary Operators （一元操作符, 例如<code>-</code>，<code>!</code> 等）</li>
<li>Binary Operators （二元操作符，例如<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code> 等）</li>
<li>Ternary Operators （三元操作符，例如<code>?</code>）</li>
</ul>
<h5 id="Assignment-Operator（赋值操作符）"><a href="#Assignment-Operator（赋值操作符）" class="headerlink" title="Assignment Operator（赋值操作符）="></a>Assignment Operator（赋值操作符）<code>=</code></h5><pre><code class="Swift">let b = 10
var a = 5
a = b
let (x, y) = (1, 2)
</code></pre>
<p>不同于 C 和 C++，他不会返回任何值，所以在下面的例子中会报错，很好的防止了手误导致错误</p>
<pre><code class="Swift">if x = y &#123; // Error
&#125;
</code></pre>
<h5 id="Arithmetic-Operators-（算术操作符）"><a href="#Arithmetic-Operators-（算术操作符）" class="headerlink" title="Arithmetic Operators （算术操作符）"></a>Arithmetic Operators （算术操作符）</h5><p>不同于 C 或 C++，Swift 不允许溢出</p>
<pre><code class="Swift">let a: UInt8 = 1 + 2
let b: UInt8 = 255
print(a + b) // Error，溢出了
print(a &amp;+ b) // 输出 2
</code></pre>
<h5 id="Remainder-Operator（取余操作符）"><a href="#Remainder-Operator（取余操作符）" class="headerlink" title="Remainder Operator（取余操作符）"></a>Remainder Operator（取余操作符）</h5><pre><code class="Swift">9 % 4 = 1
9 % -4 = 1
-9 % 4 = -1
-9 % -4 = -1
</code></pre>
<h5 id="Unary-Minus-Operator-（一元减号操作符）"><a href="#Unary-Minus-Operator-（一元减号操作符）" class="headerlink" title="Unary Minus Operator （一元减号操作符）"></a>Unary Minus Operator （一元减号操作符）</h5><pre><code class="Swift">let three = 3
let minusThree = -three // minusThree = -3
let plusThree = -minusThree // plusThree = 3
</code></pre>
<h5 id="Unary-Plus-Operator-（一元加号操作符）"><a href="#Unary-Plus-Operator-（一元加号操作符）" class="headerlink" title="Unary Plus Operator （一元加号操作符）"></a>Unary Plus Operator （一元加号操作符）</h5><p>没啥用，主要功能是对齐格式，例如</p>
<pre><code class="Swift">let minusSix = -6
let  plusSix = +6
</code></pre>
<h3 id="Compound-Assignment-Operator-（复合赋值操作符）"><a href="#Compound-Assignment-Operator-（复合赋值操作符）" class="headerlink" title="Compound Assignment Operator （复合赋值操作符）"></a>Compound Assignment Operator （复合赋值操作符）</h3><pre><code class="Swift">var a = 1
a += 2 // a = 3
a *= 2 // a = 6
a /= 3 // a = 2
// 它不会返回任何值，所以不能写成下面的样子
let b = a += 2 // Error
</code></pre>
<h3 id="Comparison-Operator-（比较操作符）"><a href="#Comparison-Operator-（比较操作符）" class="headerlink" title="Comparison Operator （比较操作符）"></a>Comparison Operator （比较操作符）</h3><p>比较语句会返回一个布尔值</p>
<pre><code class="Swift">1 == 1   // true
2 != 1   // true
2 &gt; 1    // true
1 &lt; 2    // true
1 &gt;= 1   // true
2 &lt;= 1   // false
</code></pre>
<p>元组的比较<br>仅当两个元组类型完全一样的时候才可以比较，例如</p>
<pre><code class="Swift">let a = (1, 2)
let b = (2, 3)
a == b // 可以比较

let c = (2, &quot;2&quot;)
a == c // 不能比较，类型不一致

let d = (1, 2, 3)
a == d // 不能比较，数量不一致
</code></pre>
<p>满足数量与类型的条件后，开始从第一个值开始一次比较，如果每一个值都相等，那么这两个元组就是相等的</p>
<pre><code class="Swift">let a = (1, 2, &quot;3&quot;)
let b = (1, 2, &quot;3&quot;)
a == b // True
</code></pre>
<p>当遇到两个不相等的值的时候，比较这两值，将结果作为这两个元组的比较结果返回，并停止后续的比较</p>
<pre><code class="Swift">(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;)   // true because 1 is less than 2; &quot;zebra&quot; and &quot;apple&quot; aren&#39;t compared
(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;)    // true because 3 is equal to 3, and &quot;apple&quot; is less than &quot;bird&quot;
(4, &quot;dog&quot;) == (4, &quot;dog&quot;)      // true because 4 is equal to 4, and &quot;dog&quot; is equal to &quot;dog”
</code></pre>
<p>假如元组中包含了不能够比较类型，例如 Bool，则这两个元组是不能进行大小比较的，但是可以进行相等比较</p>
<pre><code class="Swift">let a = (true, true)
let b = (false, false)
a &lt; b // Error
a == b // false
</code></pre>
<h3 id="Ternary-Conditional-Operator-（三元条件操作符）"><a href="#Ternary-Conditional-Operator-（三元条件操作符）" class="headerlink" title="Ternary Conditional Operator （三元条件操作符）"></a>Ternary Conditional Operator （三元条件操作符）</h3><p><code>?</code>操作符</p>
<pre><code class="Swift">let a = 1 &gt; 2 ? 1 : 2 // a = 2
</code></pre>
<h3 id="Nil-Coalescing-Operator-（空合运算符）"><a href="#Nil-Coalescing-Operator-（空合运算符）" class="headerlink" title="Nil-Coalescing Operator （空合运算符）"></a>Nil-Coalescing Operator （空合运算符）</h3><pre><code class="Swift">var a: String?
var b = a ?? &quot;a is nil&quot; // b = &quot;a is nil&quot;
a = &quot;123&quot;
b = a ?? &quot;a is nil&quot; // b = &quot;123&quot;
</code></pre>
<h3 id="Range-Operator-（区间运算符）"><a href="#Range-Operator-（区间运算符）" class="headerlink" title="Range Operator （区间运算符）"></a>Range Operator （区间运算符）</h3><h5 id="Closed-Range-Operator-（闭区间范围运算符）"><a href="#Closed-Range-Operator-（闭区间范围运算符）" class="headerlink" title="Closed Range Operator （闭区间范围运算符）"></a>Closed Range Operator （闭区间范围运算符）</h5><pre><code class="Swift">for index in 1...5 &#123;
    print(index)
&#125;
// 1
// 2
// 3
// 4
// 5
</code></pre>
<h5 id="Half-Open-Range-Operator-（半开区间运算符）"><a href="#Half-Open-Range-Operator-（半开区间运算符）" class="headerlink" title="Half-Open Range Operator （半开区间运算符）"></a>Half-Open Range Operator （半开区间运算符）</h5><pre><code class="Swift">for i in 1..&lt;5 &#123;
    print(i)
&#125;
// 1
// 2
// 3
// 4
</code></pre>
<h5 id="One-Sided-Ranges-（单边区间运算符）"><a href="#One-Sided-Ranges-（单边区间运算符）" class="headerlink" title="One-Sided Ranges （单边区间运算符）"></a>One-Sided Ranges （单边区间运算符）</h5><p>1、指定了起始点</p>
<pre><code class="Swift">for i in 1... &#123;
    print(i)
&#125;
// 1
// 2
// 3
// 4
// ......

let list = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]
for str in list[2...] &#123;
    print(str)
&#125;
// 3
// 4
</code></pre>
<p>2、指定结束点，</p>
<pre><code class="Swift">let list = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]
for str in list[...2] &#123;
    print(str)
&#125;
// 1
// 2
// 3

// 作为序列时，不可打印
for i in ...1 &#123;
    print(i) // Error
&#125;
let range = ...5
range.contains(7) // false
range.contains(4) // true
range.contains(-1) // true
</code></pre>
<h3 id="Logical-Operator-（逻辑操作符）"><a href="#Logical-Operator-（逻辑操作符）" class="headerlink" title="Logical Operator （逻辑操作符）"></a>Logical Operator （逻辑操作符）</h3><h5 id="Logical-NOT-Operator-（逻辑非）"><a href="#Logical-NOT-Operator-（逻辑非）" class="headerlink" title="Logical NOT Operator （逻辑非）"></a>Logical NOT Operator （逻辑非）</h5><pre><code class="Swift">let allowedEntry = false
if !allowedEntry &#123;
    print(&quot;ACCESS DENIED&quot;)
&#125;
// Prints &quot;ACCESS DENIED&quot;
</code></pre>
<h5 id="Logical-AND-Operator-（逻辑与）"><a href="#Logical-AND-Operator-（逻辑与）" class="headerlink" title="Logical AND Operator （逻辑与）"></a>Logical AND Operator （逻辑与）</h5><pre><code class="Swift">let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode &amp;&amp; passedRetinaScan &#123;
    print(&quot;Welcome!&quot;)
&#125; else &#123;
    print(&quot;ACCESS DENIED&quot;)
&#125;
// Prints &quot;ACCESS DENIED”
</code></pre>
<h5 id="Logical-OR-Operator-（逻辑或）"><a href="#Logical-OR-Operator-（逻辑或）" class="headerlink" title="Logical OR Operator （逻辑或）"></a>Logical OR Operator （逻辑或）</h5><pre><code class="Swift">let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword &#123;
    print(&quot;Welcome!&quot;)
&#125; else &#123;
    print(&quot;ACCESS DENIED&quot;)
&#125;
// Prints &quot;Welcome!&quot;
</code></pre>
<h5 id="Combining-Logical-Operator-（组合逻辑）"><a href="#Combining-Logical-Operator-（组合逻辑）" class="headerlink" title="Combining Logical Operator （组合逻辑）"></a>Combining Logical Operator （组合逻辑）</h5><pre><code class="Swift">if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123;
    print(&quot;Welcome!&quot;)
&#125; else &#123;
    print(&quot;ACCESS DENIED&quot;)
&#125;
// Prints &quot;Welcome!&quot;
</code></pre>
<p>Swift 默认顺序是从左到右的，但是为了方便阅读，最好加上括号显式指定顺序</p>
<h5 id="Explicit-Parentheses-（显式括号）"><a href="#Explicit-Parentheses-（显式括号）" class="headerlink" title="Explicit Parentheses （显式括号）"></a>Explicit Parentheses （显式括号）</h5><pre><code class="Swift">if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123;
    print(&quot;Welcome!&quot;)
&#125; else &#123;
    print(&quot;ACCESS DENIED&quot;)
&#125;
// Prints &quot;Welcome!&quot;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Swift基础</title>
    <url>/2018/07/25/Swift%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="Constants-and-Variables-（常量与变量）"><a href="#Constants-and-Variables-（常量与变量）" class="headerlink" title="Constants and Variables （常量与变量）"></a>Constants and Variables （常量与变量）</h3><h5 id="Declaring-Constants-and-Variables-（声明常量与变量）"><a href="#Declaring-Constants-and-Variables-（声明常量与变量）" class="headerlink" title="Declaring Constants and Variables （声明常量与变量）"></a>Declaring Constants and Variables （声明常量与变量）</h5><pre><code class="Swift">/// 常量，不可变
let maximumNumberOfLoginAttempts = 10
/// 变量，可变
var currentLoginAttempt = 0
/// 一次声明多个常量或变量
var x = 0.0, y = 0.0, z = 0.0
let a = 1.0, b = 2.0, c = 3.0
</code></pre>
<p>注意：<br>如果一个值它永远不会改变，则使用 let 来声明它，否则使用 var</p>
<h5 id="Type-Annotation-（类型注释）"><a href="#Type-Annotation-（类型注释）" class="headerlink" title="Type Annotation （类型注释）"></a>Type Annotation （类型注释）</h5><pre><code class="Swift">/// 字符串变量
var welcomeMessage: String
/// 一次声明多个变量并指定类型
var red, green, blue: Double
</code></pre>
<p>注意：<br>由于类型推断的存在，大多数情况下都不需要提供类型注释，因为编译器会自动根据初始值来推断当前量的类型，仅当没有提供初始值的情况下，才使用类型注释</p>
<h5 id="Nameing-Constants-and-Variables-（变量与常量的命名）"><a href="#Nameing-Constants-and-Variables-（变量与常量的命名）" class="headerlink" title="Nameing Constants and Variables （变量与常量的命名）"></a>Nameing Constants and Variables （变量与常量的命名）</h5><pre><code class="Swift">let n = 3.14159
let 你好 = &quot;你好世界&quot;
let 🐶🐮 = &quot;dogcow&quot;
</code></pre>
<p>注意：<br>如果使用 Swift 的保留字，需要用（&#96;）把它包起来</p>
<h5 id="Printing-Constants-and-Variables-（打印常量或变量）"><a href="#Printing-Constants-and-Variables-（打印常量或变量）" class="headerlink" title="Printing Constants and Variables （打印常量或变量）"></a>Printing Constants and Variables （打印常量或变量）</h5><p>使用 print 函数</p>
<h3 id="Comments-（注释）"><a href="#Comments-（注释）" class="headerlink" title="Comments （注释）"></a>Comments （注释）</h3><pre><code class="Swift">// 单行注释
/* 多行注释   
   多行注释 */ 
/* 多行注释嵌套
    /* 第二个多行注释 1
    第二个多行注释 2 */
    多行注释结束 */
</code></pre>
<h3 id="Semicolons-（分号）"><a href="#Semicolons-（分号）" class="headerlink" title="Semicolons （分号）"></a>Semicolons （分号）</h3><p>Swift 在语句结尾处不需要分号，除非你想在一行中写多条语句</p>
<pre><code class="Swift">print(&quot;1&quot;)
print(&quot;1&quot;);print(&quot;2&quot;)
</code></pre>
<h3 id="Integers-（整数）"><a href="#Integers-（整数）" class="headerlink" title="Integers （整数）"></a>Integers （整数）</h3><p>分为有符号与无符号整数，分别又分为8、16、32、64位整数<br>Int8，UInt8，Int16，UInt16 以此类推</p>
<h5 id="Integer-Bounds-（整数边界）"><a href="#Integer-Bounds-（整数边界）" class="headerlink" title="Integer Bounds （整数边界）"></a>Integer Bounds （整数边界）</h5><pre><code class="Swift">let minValue = UInt8.min
let maxValue = UInt8.max
</code></pre>
<h5 id="Int-（整型）"><a href="#Int-（整型）" class="headerlink" title="Int （整型）"></a>Int （整型）</h5><p>Int 类型的位数随系统变化</p>
<ul>
<li>32位系统，Int 是32位整数（Int32）</li>
<li>64位系统，Int 是64位整数（Int64)</li>
</ul>
<h5 id="UInt-（无符号整型）"><a href="#UInt-（无符号整型）" class="headerlink" title="UInt （无符号整型）"></a>UInt （无符号整型）</h5><p>UInt 类型的位数随系统变化</p>
<ul>
<li>32位系统，Int 是32位无符号整数（UInt32）</li>
<li>64位系统，Int 是64位无符号整数（UInt64)</li>
</ul>
<h3 id="Floating-Point-Numbers-（浮点数）"><a href="#Floating-Point-Numbers-（浮点数）" class="headerlink" title="Floating-Point Numbers （浮点数）"></a>Floating-Point Numbers （浮点数）</h3><ul>
<li>Double 64位浮点数</li>
<li>Float 32位浮点数</li>
</ul>
<h3 id="Type-Safety-and-Type-Inference-（类型安全与类型推断）"><a href="#Type-Safety-and-Type-Inference-（类型安全与类型推断）" class="headerlink" title="Type Safety and Type Inference （类型安全与类型推断）"></a>Type Safety and Type Inference （类型安全与类型推断）</h3><pre><code class="Swift">let meaningOfLife = 42
/// Int
let pi = 3.14159
/// Double
let another = 3 + 0.14159
/// Double
</code></pre>
<h3 id="Numeric-Literals-（数字字面值）"><a href="#Numeric-Literals-（数字字面值）" class="headerlink" title="Numeric Literals （数字字面值）"></a>Numeric Literals （数字字面值）</h3><pre><code class="Swift">let decimalInteger = 17
let binaryInteger = 0b10001
let octalInteger = 0o21
let hexadecimalInteger = 0x11
</code></pre>
<p>分隔符</p>
<pre><code class="Swift">let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>
<h3 id="Numeric-Type-Conversion-（数字类型转换）"><a href="#Numeric-Type-Conversion-（数字类型转换）" class="headerlink" title="Numeric Type Conversion （数字类型转换）"></a>Numeric Type Conversion （数字类型转换）</h3><h5 id="Integer-Conversion-（整型转换）"><a href="#Integer-Conversion-（整型转换）" class="headerlink" title="Integer Conversion （整型转换）"></a>Integer Conversion （整型转换）</h5><pre><code class="Swift">let cannotBeNegative: UInt8 = -1
/// Error
let tooBig: Int8 = Int8.max + 1
/// Error
</code></pre>
<pre><code class="Swift">let twoThousand: UInt16 = 2_000 // UInt16
let one: UInt8 = 1 // UInt8
let twoThousandAndOne = twoThousand + UInt16(one) // UInt16
</code></pre>
<h5 id="Integer-and-Floating-Point-Conversion-（整型浮点型转换）"><a href="#Integer-and-Floating-Point-Conversion-（整型浮点型转换）" class="headerlink" title="Integer and Floating-Point Conversion （整型浮点型转换）"></a>Integer and Floating-Point Conversion （整型浮点型转换）</h5><pre><code class="Swift">let three = 3 // Int
let pointOneFourOneFiveNine = 0.14159 // Double
let pi = Double(three) + pointOneFourOneFiveNone // Double
</code></pre>
<pre><code class="Swift">let integerPi = Int(3.14) // Int, 3
let a = Int(4.75) // 4
let b = Int(-3.9) // -3
</code></pre>
<h3 id="Type-Aliases-（类型别名）"><a href="#Type-Aliases-（类型别名）" class="headerlink" title="Type Aliases （类型别名）"></a>Type Aliases （类型别名）</h3><pre><code class="Swift">typealias AudioSample = UInt16
var maxAmplitudeFound = AudioSample.min
</code></pre>
<h3 id="Booleans-（布尔值）"><a href="#Booleans-（布尔值）" class="headerlink" title="Booleans （布尔值）"></a>Booleans （布尔值）</h3><pre><code class="Swift">let orangesAreOrange = true
let turnipsAreDelicious = false
if turnipsAreDelicious &#123;
    print(&quot;Mmm, tasty turnips!&quot;)
&#125; else &#123;
    print(&quot;Eww, turnips are horrible.&quot;)
&#125;
let i = 1
if i &#123;
    // 错误，i 不是布尔值
&#125;
if i == 1 &#123;
    // 正确，i == 1 是布尔值（true）
&#125;
</code></pre>
<h3 id="Tuples-（元组）"><a href="#Tuples-（元组）" class="headerlink" title="Tuples （元组）"></a>Tuples （元组）</h3><pre><code class="Swift">let http404Error = (404, &quot;Not Found&quot;)
</code></pre>
<p>通过名字访问</p>
<pre><code class="Swift">let (statusCode, statusMessage) = http404Error
print(&quot;The status code is \(statusCode)&quot;)
print(&quot;The status message is \(statusMessage)&quot;)
</code></pre>
<p>对于不关心的内容，使用下划线省略</p>
<pre><code class="Swift">let (justTheStatusCode, _) = http404Error
print(&quot;The status code is \(justTheStatusCode)&quot;)
</code></pre>
<p>也可以使用下标访问</p>
<pre><code class="Swift">print(&quot;The status code is \(http404Error.0)&quot;) // 404
print(&quot;The status code is \(http404Error.1)&quot;) // Not Found
</code></pre>
<p>也可以在初始化的时候命名</p>
<pre><code class="Swift">let http200Status = (statusCode: 200, description: &quot;OK&quot;)
print(&quot;The status code is \(http200Status.statusCode)&quot;) // 200
print(&quot;The status message is \(http200Status.description)&quot;) // OK
</code></pre>
<h3 id="Optional-（可选值）"><a href="#Optional-（可选值）" class="headerlink" title="Optional （可选值）"></a>Optional （可选值）</h3><pre><code class="Swift">let possibleNumber = &quot;123&quot;
let convertedNumber = Int(possibleNumber) // Int?, 123 
</code></pre>
<pre><code class="Swift">let possibleNumber = &quot;bzz&quot;
let convertedNumber = Int(possibleNumber) // Int?, nil 
</code></pre>
<h5 id="nil-（空）"><a href="#nil-（空）" class="headerlink" title="nil （空）"></a>nil （空）</h5><pre><code class="Swift">var serverResponseCode: Int? = 404
serverResponseCode = nil
</code></pre>
<pre><code class="Swift">var surveyAnswer: String?
</code></pre>
<h5 id="If-Statements-and-Forced-Unwrapping-（if-语句和强制解包）"><a href="#If-Statements-and-Forced-Unwrapping-（if-语句和强制解包）" class="headerlink" title="If Statements and Forced Unwrapping （if 语句和强制解包）"></a>If Statements and Forced Unwrapping （if 语句和强制解包）</h5><pre><code class="Swift">let convertedNumber: Int? = 1
if convertedNumber != nil &#123;
    print(&quot;convertedNumber contains some integer value.&quot;)
&#125; else &#123;
    print(&quot;convertedNumber is nil&quot;)
&#125;
</code></pre>
<p>使用（!）强制解包</p>
<pre><code class="Swift">if convertedNumber != nil &#123;
    print(&quot;convertedNumber has an integer value of \(convertedNumber!)&quot;)
&#125;
</code></pre>
<h5 id="Optional-Binding-（可选值绑定）"><a href="#Optional-Binding-（可选值绑定）" class="headerlink" title="Optional Binding （可选值绑定）"></a>Optional Binding （可选值绑定）</h5><p>语法格式<br>if let <code>constantName</code> &#x3D; <code>someOptional</code> {<br>    <code>statements</code><br>}</p>
<pre><code class="Swift">var possibleNumber = &quot;123&quot;
if let actualNumber = Int(possibleNumber) &#123;
    /// 如果 actualNumber != nil，执行后面语句
&#125; else &#123;
    /// 如果 actualNumber == nil，执行后面的语句
&#125;
</code></pre>
<p>也可以嵌套使用，同时可以添加判断语句</p>
<pre><code class="Swift">if let firstNumber = Int(&quot;4&quot;), let secondNumber = Int(&quot;42&quot;), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123;
    print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)
&#125;

if let firstNumber = Int(&quot;4&quot;) &#123;
    if let secondNumber = Int(&quot;42&quot;) &#123;
        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123;
            print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Implicitly-Unwrapped-Optionals-（可选值隐式解包）"><a href="#Implicitly-Unwrapped-Optionals-（可选值隐式解包）" class="headerlink" title="Implicitly Unwrapped Optionals （可选值隐式解包）"></a>Implicitly Unwrapped Optionals （可选值隐式解包）</h5><pre><code class="Swift">/// 普通方式
let possibleString: String = &quot;An optional string.&quot;
let forcedString: String = possibleString!

/// 隐式解包
let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;
let implicitString: String = assumedString // implicitString is String
let optionalString = assumedString // optionalString is String?

/// 注意
let assumedString: String!
let implicitString: String = assumedString // Error
</code></pre>
<h3 id="Error-Handling-（错误处理）"><a href="#Error-Handling-（错误处理）" class="headerlink" title="Error Handling （错误处理）"></a>Error Handling （错误处理）</h3><p>会抛出异常的函数，会在方法声明中加上 <code>throws</code> 关键字</p>
<pre><code class="Swift">func canThrowAnError() throws -&gt; Void &#123;

&#125;
</code></pre>
<p>错误处理</p>
<pre><code class="Swift">do &#123;
    try canThrowAnError()
    // no error was thrown
&#125; catch &#123;
    // an error was thrown
    // error 是错误的默认名称
    print(error)
&#125;
</code></pre>
<pre><code class="Swift">func makeASandwich() throws &#123;
    // ...
&#125;

do &#123;
    try makeASandwich()
    eatASandwich()
&#125; catch SandwichError.outOfCleanDishes &#123;
    washDishes()
&#125; catch SandwichError.missingIngredients(let ingredients) &#123;
    buyGroceries(ingredients)
&#125;
</code></pre>
<h3 id="Assertions-and-Preconditions-（断言与先决条件）"><a href="#Assertions-and-Preconditions-（断言与先决条件）" class="headerlink" title="Assertions and Preconditions （断言与先决条件）"></a>Assertions and Preconditions （断言与先决条件）</h3><p>assertion - 开发环境<br>precondition - 开发环境 + 生产环境</p>
<pre><code class="Swift">let age = -3
assert(age &gt;= 0, &quot;A person&#39;s age can&#39;t be less than zero.&quot;)
</code></pre>
<p>直接抛出异常的情况，不需要判断条件</p>
<pre><code class="Swift">assertionFailure(&quot;some message&quot;)
</code></pre>
<h5 id="Enforcing-Presonditions-（强制先决条件）"><a href="#Enforcing-Presonditions-（强制先决条件）" class="headerlink" title="Enforcing Presonditions （强制先决条件）"></a>Enforcing Presonditions （强制先决条件）</h5><p>precondition<br>preconditionFailure<br>参考 assertion</p>
]]></content>
  </entry>
  <entry>
    <title>Swift字符串</title>
    <url>/2018/07/28/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="Strings-and-Characters"><a href="#Strings-and-Characters" class="headerlink" title="Strings and Characters"></a>Strings and Characters</h3><h5 id="String-Literals-（字符串字面量）"><a href="#String-Literals-（字符串字面量）" class="headerlink" title="String Literals （字符串字面量）"></a>String Literals （字符串字面量）</h5><pre><code class="Swift">let someString = &quot;Some string literal value&quot;
</code></pre>
<h5 id="Multiline-String-Literals-（多行字符串字面量）"><a href="#Multiline-String-Literals-（多行字符串字面量）" class="headerlink" title="Multiline String Literals （多行字符串字面量）"></a>Multiline String Literals （多行字符串字面量）</h5><p>以 <code>&quot;&quot;&quot;</code> 开头与结尾，开头与结尾处的换行会被省略</p>
<pre><code class="Swift">let quotation = &quot;&quot;&quot;
The White Rabbit put on his spectacles.  &quot;Where shall I begin,
please your Majesty?&quot; he asked.

&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on
till you come to the end; then stop.&quot;
&quot;&quot;&quot;
print(quotation)
print(&quot;end&quot;)
// Prints
// The White Rabbit put on his spectacles.  &quot;Where shall I begin,
// please your Majesty?&quot; he asked.

// &quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on
// till you come to the end; then stop.&quot;
// end
</code></pre>
<p>如果不想换行，加入 <code>\</code> 符号，例如</p>
<pre><code class="Swift">let softWrappedQuotation = &quot;&quot;&quot;
The White Rabbit put on his spectacles.  &quot;Where shall I begin, \
please your Majesty?&quot; he asked.

&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on \
till you come to the end; then stop.&quot;
&quot;&quot;&quot;
print(softWrappedQuotation)
print(&quot;end&quot;)
// Prints
// The White Rabbit put on his spectacles.  &quot;Where shall I begin, please your Majesty?&quot; he asked.
//
// &quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on till you come to the end; then stop.&quot;
// end
</code></pre>
<pre><code class="Swift">let lineBreaks = &quot;&quot;&quot;

This string starts with a line break.
It also ends with a line break.

&quot;&quot;&quot;
print(lineBreaks)
print(&quot;end&quot;)
// Prints
//
// This string starts with a line break.
// It also ends with a line break.
// 
// end
</code></pre>
<p>结尾处的 <code>&quot;&quot;&quot;</code> 的位置，代表了整段文字的起始位置</p>
<pre><code class="Swift">let lineBreaks = &quot;&quot;&quot;

     This string starts with a line break.
   It also ends with a line break.

   &quot;&quot;&quot;
print(lineBreaks)
print(&quot;end&quot;)
// Prints
//
//   This string starts with a line break.
// It also ends with a line break.
// 
// end
</code></pre>
<h5 id="Special-Characters-in-String-Literals-（字面量中的特殊字符）"><a href="#Special-Characters-in-String-Literals-（字面量中的特殊字符）" class="headerlink" title="Special Characters in String Literals （字面量中的特殊字符）"></a>Special Characters in String Literals （字面量中的特殊字符）</h5><ul>
<li><code>\0</code> 空字符</li>
<li><code>\\</code> 反斜杠</li>
<li><code>\t</code> 跳至下一制表符位置（Tab）</li>
<li><code>\n</code> 换行符</li>
<li><code>\r</code> 回车符</li>
<li><code>\&quot;</code> 双引号</li>
<li><code>\&#39;</code> 单引号</li>
<li><code>\u&#123;n&#125;</code> Unicode字符，n 为1-8位十六进制数字</li>
</ul>
<pre><code class="Swift">let wiseWords = &quot;\&quot;Imagination is more important than knowledge\&quot; - Einstein&quot;
// &quot;Imagination is more important than knowledge&quot; - Einstein
let dollarSign = &quot;\u&#123;24&#125;&quot;        // $,  Unicode scalar U+0024
let blackHeart = &quot;\u&#123;2665&#125;&quot;      // ♥,  Unicode scalar U+2665
let sparklingHeart = &quot;\u&#123;1F496&#125;&quot; // 💖, Unicode scalar U+1F496&quot;
</code></pre>
<p>想要在多行字符串字面量中添加<code>&quot;&quot;&quot;</code>，需要使用转义字符<code>\&quot;&quot;&quot;</code>或者一个一个转义<code>\&quot;</code></p>
<pre><code class="Swift">let threeDoubleQuotationMarks = &quot;&quot;&quot;
Escaping the first quotation mark \&quot;&quot;&quot;
Escaping all three quotation marks \&quot;\&quot;\&quot;
&quot;&quot;&quot;
print(threeDoubleQuotationMarks)
print(&quot;end&quot;)
/// Prints
/// Escaping the first quotation mark &quot;&quot;&quot;
/// Escaping all three quotation marks &quot;&quot;&quot;
/// end
</code></pre>
<h5 id="Extended-String-Delimiters-（扩展字符定界）"><a href="#Extended-String-Delimiters-（扩展字符定界）" class="headerlink" title="Extended String Delimiters （扩展字符定界）"></a>Extended String Delimiters （扩展字符定界）</h5><p>可以将字符串用<code>#</code>包起来，那么字符串里面的转义字符则不会转义，直接输出，例如</p>
<pre><code class="Swift">let threeMoreDoubleQuotationMarks = #&quot;&quot;&quot;
Here are three more double quotes: &quot;&quot;&quot;
&quot;&quot;&quot;#
print(threeMoreDoubleQuotationMarks)
print(&quot;end&quot;)
/// Prints
/// Here are three more double quotes: &quot;&quot;&quot;
/// end
</code></pre>
<h3 id="Initializing-an-Empty-String-（初始化空字符串）"><a href="#Initializing-an-Empty-String-（初始化空字符串）" class="headerlink" title="Initializing an Empty String （初始化空字符串）"></a>Initializing an Empty String （初始化空字符串）</h3><pre><code class="Swift">var emptyString = &quot;&quot; // 直接用字面量
var anotherEmptyString = String() // 使用初始化方法
if emptyString.isEmpty &#123;
  print(&quot;Nothing to see here&quot;)
&#125;
/// 使用 isEmpty 属性来判断字符串是否为空
/// Prints
/// Nothing to see here
</code></pre>
<h3 id="String-Mutability-（字符串的可变性）"><a href="#String-Mutability-（字符串的可变性）" class="headerlink" title="String Mutability （字符串的可变性）"></a>String Mutability （字符串的可变性）</h3><pre><code class="Swift">// var 可变
var variableString = &quot;Horse&quot;
variableString += &quot; and carriage&quot;
// variableString is now &quot;Horse and carriage&quot;

// let 不可变
let constantString = &quot;Highlander&quot;
constantString += &quot; and another Highlander&quot;
// this reports a compile-time error - a constant string cannot be modified
</code></pre>
<h3 id="Strings-Are-Value-Types-（字符串是值类型）"><a href="#Strings-Are-Value-Types-（字符串是值类型）" class="headerlink" title="Strings Are Value Types （字符串是值类型）"></a>Strings Are Value Types （字符串是值类型）</h3><p>Swift 中的 String 类型是值类型，也就是说如果你创建一个新的字符串，用来作为函数的参数或者复制到某个变量、常量上，它都会先复制一份新的，然后使用新的值来做这些事情。</p>
<h3 id="Working-with-Characters-（使用字符）"><a href="#Working-with-Characters-（使用字符）" class="headerlink" title="Working with Characters （使用字符）"></a>Working with Characters （使用字符）</h3><p>可以使用 for-in 来遍历字符串中的字符</p>
<pre><code class="Swift">for character in &quot;Dog!🐶&quot; &#123;
    print(character)
&#125;
// D
// o
// g
// !
// 🐶
</code></pre>
<p>或者直接指定某个变量的类型为 Character 然后对它进行赋值</p>
<pre><code class="Swift">let exclamationMark: Character = &quot;!&quot; // exclamationMark is Character
let anotherMark = &quot;!&quot; // anotherMark is String
</code></pre>
<p>也可以通过字符数组来创建字符串</p>
<pre><code class="Swift">let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;🐱&quot;]
let catString = String(catCharacters)
print(catString)
// Prints &quot;Cat!🐱
</code></pre>
<h3 id="Concatenating-Strings-and-Characters-（串联字符与字符串）"><a href="#Concatenating-Strings-and-Characters-（串联字符与字符串）" class="headerlink" title="Concatenating Strings and Characters （串联字符与字符串）"></a>Concatenating Strings and Characters （串联字符与字符串）</h3><p>String + String</p>
<pre><code class="Swift">let string1 = &quot;hello&quot;
let string2 = &quot; there&quot;
var welcome = string1 + string2
// welcome is &quot;hello there&quot;
</code></pre>
<p>String +&#x3D; String</p>
<pre><code class="Swift">var instruction = &quot;look over&quot;
var string2 = &quot; there&quot;
instruction += string2
// instruction is &quot;look over there&quot;
</code></pre>
<p>String.append(Character)</p>
<pre><code class="Swift">welcome = &quot;hello there&quot;
var exclamationMark: Character = &quot;!&quot;
welcome.append(exclamationMark)
// welcome is &quot;hello there!&quot;
</code></pre>
<p>多行字符串</p>
<pre><code class="Swift">let badStart = &quot;&quot;&quot;
one
two
&quot;&quot;&quot;
let end = &quot;&quot;&quot;
three
&quot;&quot;&quot;
print(badStart + end)
// Prints two lines:
// one
// twothree

let goodStart = &quot;&quot;&quot;
one
two

&quot;&quot;&quot;
print(goodStart + end)
// Prints three lines:
// one
// two
// three
</code></pre>
<h3 id="String-interpolation-（字符串插值）"><a href="#String-interpolation-（字符串插值）" class="headerlink" title="String interpolation （字符串插值）"></a>String interpolation （字符串插值）</h3><p>通过字符串插值可以很容易地在字符串中插入变量、表达式、函数等等</p>
<pre><code class="Swift">let multiplier = 3
let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;
// message is &quot;3 times 2.5 is 7.5&quot;
</code></pre>
<p>使用<code>#</code>会使字符串插值失效</p>
<pre><code class="Swift">let multiplier = 3
let message = #&quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;#
// message is &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;
</code></pre>
<p>想要让字符串插值仍然生效，需要在字符串插值中加上<code>#</code></p>
<pre><code class="Swift">let multiplier = 3
let message = #&quot;\#(multiplier) times 2.5 is \#(Double(multiplier) * 2.5)&quot;#
// message is &quot;3 times 2.5 is 7.5&quot;
</code></pre>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><h5 id="Unicode-Scalar-Values-（Unicode-标量）"><a href="#Unicode-Scalar-Values-（Unicode-标量）" class="headerlink" title="Unicode Scalar Values （Unicode 标量）"></a>Unicode Scalar Values （Unicode 标量）</h5><pre><code class="Swift">let a = &quot;\u&#123;0061&#125;&quot; // 0061 = 0x0061
let b = &quot;\u&#123;1F425&#125;&quot; // 1F425 = 0x1F425
print(a+b)
print(&quot;end&quot;)
// Prints
// a🐥
// end
</code></pre>
<h5 id="Extended-Graphoeme-Clusters-（扩展字形集群）"><a href="#Extended-Graphoeme-Clusters-（扩展字形集群）" class="headerlink" title="Extended Graphoeme Clusters （扩展字形集群）"></a>Extended Graphoeme Clusters （扩展字形集群）</h5><p>Swift 中每一个 Character 都是一个单独的扩展字形集群。它是一个由一个或多个 Unicode 纯量组合而成的字符，例如：</p>
<pre><code class="Swift">let eAcute: Character = &quot;\u&#123;E9&#125;&quot;
let decoration: Character = &quot;\u&#123;301&#125;&quot;
let combine = &quot;\u&#123;E9&#125;\u&#123;301&#125;&quot;
print(eAcute)
print(decoration)
print(combine)
print(&quot;end&quot;)
é
 ́
é́
end
</code></pre>
<p>另一个例子</p>
<pre><code class="Swift">let precomposed: Character = &quot;\u&#123;D55C&#125;&quot;                  // 한
let decomposed: Character = &quot;\u&#123;1112&#125;\u&#123;1161&#125;\u&#123;11AB&#125;&quot;   // ᄒ, ᅡ, ᆫ
// precomposed is 한, decomposed is 한
print(precomposed)
print(decomposed)
print(&quot;end&quot;)
// Prints
// 한
// 한
// end
</code></pre>
<p>或者国旗</p>
<pre><code class="Swift">var a = &quot;\u&#123;1F1FA&#125;&quot;; // 🇺
var b = &quot;\u&#123;1F1F8&#125;&quot; // 🇸
var ab: Character = &quot;\u&#123;1F1FA&#125;\u&#123;1F1F8&#125;&quot; // 🇺🇸
a = &quot;\u&#123;1F1E8&#125;&quot; // 🇨
b = &quot;\u&#123;1F1F3&#125;&quot; // 🇳
ab = &quot;\u&#123;1F1E8&#125;\u&#123;1F1F3&#125;&quot; // 🇨🇳
</code></pre>
<h3 id="Counting-Characters-（字符数量）"><a href="#Counting-Characters-（字符数量）" class="headerlink" title="Counting Characters （字符数量）"></a>Counting Characters （字符数量）</h3><pre><code class="Swift">var str = &quot;message&quot; // count is 7
</code></pre>
<p>假如有扩展字形集群，以最终字符数为准</p>
<pre><code class="Swift">var word = &quot;cafe&quot; // count is 4
word += &quot;\u&#123;301&#125;&quot; // word is café, count is 4
</code></pre>
<h3 id="Accessing-and-Modifying-a-String-（获取与操作字符串）"><a href="#Accessing-and-Modifying-a-String-（获取与操作字符串）" class="headerlink" title="Accessing and Modifying a String （获取与操作字符串）"></a>Accessing and Modifying a String （获取与操作字符串）</h3><h5 id="String-Indices-（字符串索引）"><a href="#String-Indices-（字符串索引）" class="headerlink" title="String Indices （字符串索引）"></a>String Indices （字符串索引）</h5><pre><code class="Swift">let greeting = &quot;Guten Tag!&quot;
greeting[greeting.startIndex] // G
greeting[greeting.index(before: greeting.endIndex)] // !
greeting[greeting.index(after: greeting.startIndex)] // u
greeting[greeting.index(greeting.startIndex, offsetBy: 7)] // a
greeting[greeting.index(greeting.endIndex, offsetBy: -1)] // !
</code></pre>
<p>超出范围的情况</p>
<pre><code class="Swift">greeting[greeting.endIndex] // Error
greeting[greeting.index(after: greeting.endIndex)] // Error
</code></pre>
<p>通过遍历索引遍历字符串，其中，terminator 是指的结束符，默认为<code>\n</code>（换行），指定为空字符串后，输出完毕不会换行了。</p>
<pre><code class="Swift">for index in greeting.indices &#123;
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)
&#125;
// Prints
// G u t e n   T a g ! 
</code></pre>
<h5 id="Inserting-and-Removing-（插入和删除）"><a href="#Inserting-and-Removing-（插入和删除）" class="headerlink" title="Inserting and Removing （插入和删除）"></a>Inserting and Removing （插入和删除）</h5><p>插入单个字符（Character）的情况</p>
<pre><code class="Swift">var welcome = &quot;hello&quot;
welcome.insert(&quot;!&quot;, at: welcome.endIndex) // welcome is &quot;hello!&quot;

var at = welcome.index(before: welcome.endIndex)
welcome[at] // !
welcome.insert(contentsOf: &quot; there&quot;, at: at) // welcome is &quot;hello there!&quot;

at = welcome.index(before: welcome.endIndex)
welcome[at] // !
welcome.remove(at: at) // welcome is &quot;hello there&quot;

let start = welcome.index(welcome.endIndex, offsetBy: -6)
welcome[start] // &quot; &quot;
let end = welcome.endIndex
let range = start..&lt;end
welcome.removeSubrange(range) // welcome is &quot;hello&quot;
</code></pre>
<h3 id="Substrings-（子串）"><a href="#Substrings-（子串）" class="headerlink" title="Substrings （子串）"></a>Substrings （子串）</h3><p>Substrings !&#x3D; String</p>
<pre><code class="Swift">let greeting = &quot;Hello, world!&quot;
let index = greeting.firstIndex(of: &quot;,&quot;) ?? greeting.endIndex
let begining: String.SubSequence = greeting[..&lt;index] // begining is &quot;Hello&quot;
let str: String = begining // Error, String is not a String.SubSequence
let str1: String = String(begining) // OK
</code></pre>
<h3 id="Comparing-Strings-（字符串比较）"><a href="#Comparing-Strings-（字符串比较）" class="headerlink" title="Comparing Strings （字符串比较）"></a>Comparing Strings （字符串比较）</h3><p>Swift 提供了三种比较文本值的方式</p>
<ul>
<li>全量比较</li>
<li>前缀比较</li>
<li>后缀比较</li>
</ul>
<h5 id="String-and-Character-Equality-（字符串与字符相等）"><a href="#String-and-Character-Equality-（字符串与字符相等）" class="headerlink" title="String and Character Equality （字符串与字符相等）"></a>String and Character Equality （字符串与字符相等）</h5><p>使用<code>==</code>与<code>!=</code>进行比较</p>
<pre><code class="Swift">let quotation = &quot;We&#39;re a lot alike, you and I.&quot;
let sameQuotation = &quot;We&#39;re a lot alike, you and I.&quot;
if quotation == sameQuotation &#123;
    print(&quot;These two strings are considered equal&quot;)
&#125;
// Prints &quot;These two strings are considered equal&quot;
</code></pre>
<p>注意，这种比较是语言的意思与外在的表现上的</p>
<pre><code class="Swift">let e1 = &quot;\u&#123;E9&#125;&quot; // é
let e2 = &quot;\u&#123;65&#125;\u&#123;301&#125;&quot; // é
print(e1 == e2) // True
</code></pre>
<p>相反的，对应英语中的”A“，和俄语中的”A“，他们是不一样的</p>
<pre><code class="Swift">let latinCapitalLetterA: Character = &quot;\u&#123;41&#125;&quot; // English A
let cyrillicCapitalLetterA: Character = &quot;\u&#123;0410&#125;&quot; // Russian A
print(latinCapitalLetterA == cyrillicCapitalLetterA) // False
</code></pre>
<h5 id="Prefix-and-Suffix-Equality-（前缀与后缀相等）"><a href="#Prefix-and-Suffix-Equality-（前缀与后缀相等）" class="headerlink" title="Prefix and Suffix Equality （前缀与后缀相等）"></a>Prefix and Suffix Equality （前缀与后缀相等）</h5><pre><code class="Swift">let romeoAndJuliet = [
    &quot;Act 1 Scene 1: Verona, A public place&quot;,
    &quot;Act 1 Scene 2: Capulet&#39;s mansion&quot;,
    &quot;Act 1 Scene 3: A room in Capulet&#39;s mansion&quot;,
    &quot;Act 1 Scene 4: A street outside Capulet&#39;s mansion&quot;,
    &quot;Act 1 Scene 5: The Great Hall in Capulet&#39;s mansion&quot;,
    &quot;Act 2 Scene 1: Outside Capulet&#39;s mansion&quot;,
    &quot;Act 2 Scene 2: Capulet&#39;s orchard&quot;,
    &quot;Act 2 Scene 3: Outside Friar Lawrence&#39;s cell&quot;,
    &quot;Act 2 Scene 4: A street in Verona&quot;,
    &quot;Act 2 Scene 5: Capulet&#39;s mansion&quot;,
    &quot;Act 2 Scene 6: Friar Lawrence&#39;s cell&quot;
]
var act1SceneCount = 0
var cellCount = 0
for scene in romeoAndJuliet &#123;
    if scene.hasPrefix(&quot;Act 1 &quot;) &#123;
        act1SceneCount += 1
    &#125;
    if scene.hasSuffix(&quot;cell&quot;) &#123;
        cellCount += 1
    &#125;
&#125;
print(&quot;There are \(act1SceneCount) scenes in Act 1&quot;)
// Prints &quot;There are 5 scenes in Act 1&quot;
print(&quot;There are \(cellCount) scenes end with \&quot;cell\&quot;&quot;)
// Prints &quot;There are 2 scenes end with &quot;cell&quot;&quot;
</code></pre>
<h3 id="Unicode-Representations-of-Strings-（Unicode字符串的表现形式）"><a href="#Unicode-Representations-of-Strings-（Unicode字符串的表现形式）" class="headerlink" title="Unicode Representations of Strings （Unicode字符串的表现形式）"></a>Unicode Representations of Strings （Unicode字符串的表现形式）</h3><p>当 Unicode 字符串要写入文件或者其他存储位置时。会有几种不同的编码格式</p>
<ul>
<li>UTF-8</li>
<li>UTF-16</li>
<li>21-bit Unicode Scalar</li>
</ul>
<h5 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h5><table>
  <tr align=center>
    <td>Character</td>
    <td>D</br><small>U+0044</small></td>
    <td>o</br><small>U+006F</small></td>
    <td>g</br><small>U+0067</small></td>
    <td colspan="3">‼</br><small>U+203C</small></td>
    <td colspan="4">🐶</br><small>U+1F436</small></td>
  </tr>
  <tr align=center>
    <td>UTF-8</br>Code Unit</td>
    <td>68</td>
    <td>111</td>
    <td>103</td>
    <td>226</td>
    <td>128</td>
    <td>188</td>
    <td>240</td>
    <td>159</td>
    <td>144</td>
    <td>182</td>
  </tr>
  <tr align=center>
    <td>Position</td>
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td>9</td>
  </tr>
</table>

<h5 id="UTF-16-Representation"><a href="#UTF-16-Representation" class="headerlink" title="UTF-16 Representation"></a>UTF-16 Representation</h5><table>
  <tr align=center>
    <td>Character</td>
    <td>D</br><small>U+0044</small></td>
    <td>o</br><small>U+006F</small></td>
    <td>g</br><small>U+0067</small></td>
    <td>‼</br><small>U+203C</small></td>
    <td colspan="2">🐶</br><small>U+1F436</small></td>
  </tr>
  <tr align=center>
    <td>UTF-8</br>Code Unit</td>
    <td>68</td>
    <td>111</td>
    <td>103</td>
    <td>8252</td>
    <td>55357</td>
    <td>56374</td>
  </tr>
  <tr align=center>
    <td>Position</td>
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
  </tr>
</table>

<h5 id="21-bit-Unicode-Scalar"><a href="#21-bit-Unicode-Scalar" class="headerlink" title="21-bit Unicode Scalar"></a>21-bit Unicode Scalar</h5><table>
  <tr align=center>
    <td>Character</td>
    <td>D</br><small>U+0044</small></td>
    <td>o</br><small>U+006F</small></td>
    <td>g</br><small>U+0067</small></td>
    <td>‼</br><small>U+203C</small></td>
    <td colspan="2">🐶</br><small>U+1F436</small></td>
  </tr>
  <tr align=center>
    <td>UTF-8</br>Code Unit</td>
    <td>68</td>
    <td>111</td>
    <td>103</td>
    <td>8252</td>
    <td>128054</td>
  </tr>
  <tr align=center>
    <td>Position</td>
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
  </tr>
</table>
]]></content>
  </entry>
  <entry>
    <title>Swift集合类型</title>
    <url>/2018/07/31/Swift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="Collection-Types-（集合类型）"><a href="#Collection-Types-（集合类型）" class="headerlink" title="Collection Types （集合类型）"></a>Collection Types （集合类型）</h3><p>Swift 提供三种基本集合类型 </p>
<ul>
<li>Array - 有序集合</li>
<li>Set - 无序但是不重复集合</li>
<li>Dictionary - 无序键值对集合</li>
</ul>
<h3 id="Mutability-of-Collections-（集合的可变性）"><a href="#Mutability-of-Collections-（集合的可变性）" class="headerlink" title="Mutability of Collections （集合的可变性）"></a>Mutability of Collections （集合的可变性）</h3><p>取决于它是变量还是常量，以数组为例</p>
<pre><code class="Swift">let listA: [Int] = [] // 不可变
var listB: [Int] = [] // 可变
</code></pre>
<h3 id="Arrays-（数组）"><a href="#Arrays-（数组）" class="headerlink" title="Arrays （数组）"></a>Arrays （数组）</h3><p>数组只能存储同类型的元素</p>
<h5 id="Array-Type-Shorthand-Syntax-（数组类型的简单表示法）"><a href="#Array-Type-Shorthand-Syntax-（数组类型的简单表示法）" class="headerlink" title="Array Type Shorthand Syntax （数组类型的简单表示法）"></a>Array Type Shorthand Syntax （数组类型的简单表示法）</h5><ul>
<li><code>Array&lt;Element&gt;</code></li>
<li><code>[Element]</code><br>他们在功能上是相同的</li>
</ul>
<h5 id="Creating-an-Empty-Array-（创建空数组）"><a href="#Creating-an-Empty-Array-（创建空数组）" class="headerlink" title="Creating an Empty Array （创建空数组）"></a>Creating an Empty Array （创建空数组）</h5><pre><code class="Swift">var someInts = [Int]() // 自动推断类型
var someInts2: [Int] // 需要指定类型
someInts2 = []
</code></pre>
<h5 id="Creating-an-Array-with-a-Default-Value-（使用默认值创建数组）"><a href="#Creating-an-Array-with-a-Default-Value-（使用默认值创建数组）" class="headerlink" title="Creating an Array with a Default Value （使用默认值创建数组）"></a>Creating an Array with a Default Value （使用默认值创建数组）</h5><pre><code class="Swift">var threeDoubles = Array(repeating: 0.0, count: 3) 
// type is [Double], value is [0.0, 0.0, 0.0]
</code></pre>
<h5 id="Creating-an-Array-by-Adding-Two-Arrays-Together-（将两个数组加到一起）"><a href="#Creating-an-Array-by-Adding-Two-Arrays-Together-（将两个数组加到一起）" class="headerlink" title="Creating an Array by Adding Two Arrays Together （将两个数组加到一起）"></a>Creating an Array by Adding Two Arrays Together （将两个数组加到一起）</h5><pre><code class="Swift">var threeDoubles = Array(repeating: 0.0, count: 3)
var anotherThreeDoubles = Array(repeating: 2.5, count: 3)
var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles is [Double], value is [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
</code></pre>
<h5 id="Creating-an-Array-with-an-Array-Literal-（使用字面量创建数组）"><a href="#Creating-an-Array-with-an-Array-Literal-（使用字面量创建数组）" class="headerlink" title="Creating an Array with an Array Literal （使用字面量创建数组）"></a>Creating an Array with an Array Literal （使用字面量创建数组）</h5><pre><code class="Swift">var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;] // 由于提供了足够的信息，类型可以省略
var shortShoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]
</code></pre>
<h5 id="Accessing-and-Modifying-an-Array-（访问与修改数组）"><a href="#Accessing-and-Modifying-an-Array-（访问与修改数组）" class="headerlink" title="Accessing and Modifying an Array （访问与修改数组）"></a>Accessing and Modifying an Array （访问与修改数组）</h5><pre><code class="Swift">var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]
shoppingList += [&quot;Baking Powder&quot;] // shoppingList is [&quot;Eggs&quot;, &quot;Milk&quot;, &quot;Flour&quot;, &quot;Baking Powder&quot;]
</code></pre>
<p>可以修改某个范围的值</p>
<pre><code class="Swift">var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;, &quot;Baking Powder&quot;]
shoppingList[1..&lt;2] = [&quot;2&quot;] // [&quot;Eggs&quot;, &quot;2&quot;, &quot;Baking Powder&quot;]
shoppingList[1...2] = [&quot;3&quot;, &quot;4&quot;] // [&quot;Eggs&quot;, &quot;3&quot;, &quot;4&quot;]
</code></pre>
<h5 id="Iterating-Over-an-Array-（遍历数组）"><a href="#Iterating-Over-an-Array-（遍历数组）" class="headerlink" title="Iterating Over an Array （遍历数组）"></a>Iterating Over an Array （遍历数组）</h5><pre><code class="Swift">let shoppingList = [&quot;Six eggs&quot;, &quot;Milk&quot;, &quot;Flour&quot;, &quot;Baking Powder&quot;, &quot;Bananas&quot;]
for item in shopplingList &#123;
    print(item)
&#125;
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
</code></pre>
<p>如果需要下标，使用<code>enumerated()</code>方法</p>
<pre><code class="Swift">for (index, value) in shoppingList.enumerated() &#123;
    print(&quot;Item \(index + 1): \(value)&quot;)
&#125;
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
</code></pre>
<h3 id="Sets-（集合）"><a href="#Sets-（集合）" class="headerlink" title="Sets （集合）"></a>Sets （集合）</h3><p>集合不能存储相同的元素</p>
<h5 id="Hash-Values-for-Set-Types-（集合类型的哈希值）"><a href="#Hash-Values-for-Set-Types-（集合类型的哈希值）" class="headerlink" title="Hash Values for Set Types （集合类型的哈希值）"></a>Hash Values for Set Types （集合类型的哈希值）</h5><p>存储在集合里的元素必须是可以哈希的，通过每个元素的哈希值来保证集合中元素的唯一性。</p>
<h5 id="Set-Type-Syntax-（集合类型语法）"><a href="#Set-Type-Syntax-（集合类型语法）" class="headerlink" title="Set Type Syntax （集合类型语法）"></a>Set Type Syntax （集合类型语法）</h5><p><code>Set&lt;Element&gt;</code>，不同于数组，它没有简写</p>
<h5 id="Creating-and-Initializing-an-Empty-Set-（创建与初始化空集合）"><a href="#Creating-and-Initializing-an-Empty-Set-（创建与初始化空集合）" class="headerlink" title="Creating and Initializing an Empty Set （创建与初始化空集合）"></a>Creating and Initializing an Empty Set （创建与初始化空集合）</h5><pre><code class="Swift">var letters = Set&lt;Character&gt;()
var letters2: Set&lt;Int&gt; = []
</code></pre>
<h5 id="Creating-a-Set-with-an-Array-Literal-（使用数组字面量来创建集合）"><a href="#Creating-a-Set-with-an-Array-Literal-（使用数组字面量来创建集合）" class="headerlink" title="Creating a Set with an Array Literal （使用数组字面量来创建集合）"></a>Creating a Set with an Array Literal （使用数组字面量来创建集合）</h5><pre><code class="Swift">var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre>
<p>由于类型推断，String 是可以省略的</p>
<pre><code class="Swift">var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre>
<h5 id="Accessing-and-Modifying-a-Set-（访问与修改集合）"><a href="#Accessing-and-Modifying-a-Set-（访问与修改集合）" class="headerlink" title="Accessing and Modifying a Set （访问与修改集合）"></a>Accessing and Modifying a Set （访问与修改集合）</h5><pre><code class="Swift">var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
favoriteGenres.count // 3
favoriteGenres.isEmpty // false
favoriteGenres.insert(&quot;1&quot;) // [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;, &quot;1&quot;]
favoriteGenres.insert(&quot;1&quot;) // 因为集合中已经有 “1” 了，所以仍然是 [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;, &quot;1&quot;]
favoriteGenres.remove(&quot;1&quot;) // [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
favoriteGenres.remove(&quot;2&quot;) // 因为集合中没有 “2”，所以仍然是 [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
favoriteGenres.contains(&quot;Rock&quot;) // true
</code></pre>
<h5 id="Iterating-Over-a-Set-（遍历集合）"><a href="#Iterating-Over-a-Set-（遍历集合）" class="headerlink" title="Iterating Over a Set （遍历集合）"></a>Iterating Over a Set （遍历集合）</h5><p>集合是无序的，所以每次打印的顺序可能不同</p>
<pre><code class="Swift">for genre in favoriteGenres &#123;
    print(&quot;\(genre)&quot;)
&#125;
// Classical
// Hip hop
// Rock
</code></pre>
<h3 id="Performing-Set-Operations-（操作集合）"><a href="#Performing-Set-Operations-（操作集合）" class="headerlink" title="Performing Set Operations （操作集合）"></a>Performing Set Operations （操作集合）</h3><h5 id="Fundamental-Set-Operations-（基本集合操作）"><a href="#Fundamental-Set-Operations-（基本集合操作）" class="headerlink" title="Fundamental Set Operations （基本集合操作）"></a>Fundamental Set Operations （基本集合操作）</h5><ul>
<li>交集 a.intersection(b)<br>既是A的元素，又是B的元素</li>
<li>并集 a.union(b)<br>是A的元素，或是B的元素</li>
<li>补集 s.subtracting(b)<br>A中不属于B的元素</li>
<li>差集 s.symmetricDifference(b)<br>只属于A和只属于B的元素<br>例子</li>
</ul>
<pre><code class="Swift">let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
print(oddDigits.union(evenDigits).sorted())
print(oddDigits.intersection(evenDigits).sorted())
print(oddDigits.subtracting(singleDigitPrimeNumbers).sorted())
print(oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted())
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// []
// [1, 9]
// [1, 2, 9]
</code></pre>
<h5 id="Set-Membership-and-Equality-（集合的关系与相等性）"><a href="#Set-Membership-and-Equality-（集合的关系与相等性）" class="headerlink" title="Set Membership and Equality （集合的关系与相等性）"></a>Set Membership and Equality （集合的关系与相等性）</h5><p>假设有 A、B、C 三个集合</p>
<pre><code class="Swift">var A: Set = [1,2,3,4,5]
var B: Set = [1,2,3]
var C: Set = [4,5,6,7,8]
var D: Set = [0]
print(A == B) // false，A、B中的元素不全相同
print(B.isSubset(of: A)) // true，B 包含于 A（子集）
print(A.isSuperset(of: B)) // true, A 包含 B（子集）
print(B.isStrictSubset(of: A)) // true，真子集，(B.isSubset(of: A) &amp;&amp; B != A)
print(A.isStrictSuperset(of: B)) // true，真子集，(A.isSuperset(of: B) &amp;&amp; A != B)
print(A.isDisjoint(with: D)) // true, A 与 D没有共有元素
</code></pre>
<h3 id="Dictionaries-（字典）"><a href="#Dictionaries-（字典）" class="headerlink" title="Dictionaries （字典）"></a>Dictionaries （字典）</h3><h5 id="Dictionary-Type-Shorthand-Syntax-（字典类型的简单句法）"><a href="#Dictionary-Type-Shorthand-Syntax-（字典类型的简单句法）" class="headerlink" title="Dictionary Type Shorthand Syntax （字典类型的简单句法）"></a>Dictionary Type Shorthand Syntax （字典类型的简单句法）</h5><p><code>Dictionary&lt;Key, Value&gt;</code>，简写<code>[Key: Value]</code><br>Key 是唯一的，所以它必须是可哈希的。</p>
<h5 id="Creating-an-Empty-Dictionary-（创建空字典）"><a href="#Creating-an-Empty-Dictionary-（创建空字典）" class="headerlink" title="Creating an Empty Dictionary （创建空字典）"></a>Creating an Empty Dictionary （创建空字典）</h5><pre><code class="Swift">var namesOfIntegers = [Int: String]()
var namesOfIntegers2: [Int: String] = [:]
</code></pre>
<h5 id="Creating-a-Dictionary-with-a-Dictionary-Literal-（使用字典字面量来创建字典）"><a href="#Creating-a-Dictionary-with-a-Dictionary-Literal-（使用字典字面量来创建字典）" class="headerlink" title="Creating a Dictionary with a Dictionary Literal （使用字典字面量来创建字典）"></a>Creating a Dictionary with a Dictionary Literal （使用字典字面量来创建字典）</h5><pre><code class="Swift">var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
var airports2 = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;] // 类型推断
</code></pre>
<h5 id="Accessing-and-Modifying-a-Dictionary-（访问和修改字典）"><a href="#Accessing-and-Modifying-a-Dictionary-（访问和修改字典）" class="headerlink" title="Accessing and Modifying a Dictionary （访问和修改字典）"></a>Accessing and Modifying a Dictionary （访问和修改字典）</h5><pre><code class="Swift">var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
airports.count 
// 2
airports.isEmpty 
// false
airports[&quot;LHR&quot;] = &quot;London&quot;
// [&quot;DUB&quot;: &quot;Dublin&quot;, &quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;LHR&quot;: &quot;London&quot;]
airports[&quot;LHR&quot;] = &quot;London Heathrow&quot; 
// 由于 Key 是唯一的，所以会更新该 Key 对应的 Value 的值 [&quot;DUB&quot;: &quot;Dublin&quot;, &quot;LHR&quot;: &quot;London Heathrow&quot;, &quot;YYZ&quot;: &quot;Toronto Pearson&quot;]
airports.updateValue(&quot;London New&quot;, forKey: &quot;LHR&quot;) 
// 等同于 airports[&quot;LHR&quot;] = &quot;London New&quot; [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;, &quot;LHR&quot;: &quot;London New&quot;]
airports[&quot;LHR&quot;] = nil 
// 删除某个 Key，[&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
</code></pre>
<h5 id="Iterating-Over-a-Dictionary-（遍历字典）"><a href="#Iterating-Over-a-Dictionary-（遍历字典）" class="headerlink" title="Iterating Over a Dictionary （遍历字典）"></a>Iterating Over a Dictionary （遍历字典）</h5><pre><code class="Swift">var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
for (key, value) in airports &#123;
    print(key + &quot; - &quot; + value)
&#125;
// DUB - Dublin
// YYZ - Toronto Pearson
</code></pre>
<p>仅遍历 Key 或 Value</p>
<pre><code class="Swift">for key in airports.keys &#123;
    print(key)
&#125;
// YYZ
// DUB
for value in airports.values &#123;
    print(value)
&#125;
// Toronto Pearson
// Dublin
</code></pre>
<p>取出 Key 或 Value 数组</p>
<pre><code class="Swift">let airportCodes = [String](airports.keys)
// airportCodes is [&quot;LHR&quot;, &quot;YYZ&quot;]

let airportNames = [String](airports.values)
// airportNames is [&quot;London Heathrow&quot;, &quot;Toronto Pearson&quot;]
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>TDD（测试驱动开发）</title>
    <url>/2022/05/10/TDD%EF%BC%88%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%EF%BC%89/</url>
    <content><![CDATA[<p>从昨天的 flutter 兼容性处理中，联想到一个概念，叫做测试驱动开发（Test-Driven Development），它是一种“测试先行”的开发模式，要求开发者先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发过程。感觉下个迭代可以尝试一下。首先涉及到几个概念</p>
<p><strong>什么是单元测试</strong></p>
<p>测试单一的函数，方法或类。单元测试的目标是验证逻辑单元在各种条件下的正确性。被测试单元的外部依赖通常需要模拟。单元测试通常<strong>不会读写磁盘</strong>，<strong>将数据渲染到屏幕</strong>，<strong>从运行测试进程的外部去接收用户的操作</strong>。</p>
<p><strong>如何写单元测试</strong></p>
<p>现在已经知道了单元测试是什么，但是好像仍然不知道该怎么写它，有一个比较简单的方式：</p>
<ol>
<li>在我们接到一个需求后，首先进行需求分析，将需求分解为任务列表，再从列表中挑选一个任务，转换成一组测试用例，然后不断重复这一步骤。</li>
<li>这样下来我们就会得到一组测试用例，它基本覆盖了所有的应用场景，为什么说是“基本”，因为可能存在一些没有考虑到的场景，后续将其补充即可。</li>
</ol>
<p><strong>使测试通过</strong></p>
<p>接着，我们以最快的方式使测试全部通过，这意味着我们通常会用最直接但可能并不优雅的方式，可能会出现大量冗余代码或者多余的代码。</p>
<p><strong>完善实现</strong><br>冗余的代码会导致维护成本的增加，多余的代码可能没有被测试覆盖到，所以在所有测试都通过后，我们需要进行优化重构，最终达到没有重复以及多余的代码的目标。</p>
]]></content>
  </entry>
  <entry>
    <title>WWDC21 - 概述</title>
    <url>/2021/06/09/WWDC21-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="iOS-15"><a href="#iOS-15" class="headerlink" title="iOS 15"></a>iOS 15</h1><h2 id="Staying-connected"><a href="#Staying-connected" class="headerlink" title="Staying connected"></a>Staying connected</h2><h3 id="FaceTime-Natural、Comfortable、Lifelike"><a href="#FaceTime-Natural、Comfortable、Lifelike" class="headerlink" title="FaceTime - Natural、Comfortable、Lifelike"></a>FaceTime - Natural、Comfortable、Lifelike</h3><ul>
<li>Spatial audio（空间音频）</li>
<li>Microphone - voice isolation（语音突显）</li>
<li>Microphone - Wide spectrum（宽频谱）</li>
<li>Portrait mode - 横屏人像模式（背景虚化）</li>
<li>FaceTime linnks - 类似于瞩目会议链接，可跨平台（其他平台使用浏览器）</li>
<li>SharePlay - Listen together, Watch together, share your screen</li>
</ul>
<h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><ul>
<li>Photo stack - 可以一次分享多个照片，会以卡片的形式叠放</li>
<li>Share with You - 分享的链接会在对应的 App 中显示，进入对应页面后，还可以显示分享者（Apple News、Apple Music、Photo、Safari、Podcasts、Apple TV）</li>
</ul>
<h2 id="Finding-focus"><a href="#Finding-focus" class="headerlink" title="Finding focus"></a>Finding focus</h2><h3 id="Notification-summary（通知摘要）"><a href="#Notification-summary（通知摘要）" class="headerlink" title="Notification summary（通知摘要）"></a>Notification summary（通知摘要）</h3><ul>
<li>把通知搜集起来，自行选择何时推送</li>
<li>联系人的通知不会出现在摘要里</li>
<li>现在使用勿扰模式的时候，Messages 会自动显示你的状态</li>
</ul>
<h3 id="Focus（专注）"><a href="#Focus（专注）" class="headerlink" title="Focus（专注）"></a>Focus（专注）</h3><ul>
<li>类似于情景模式，允许某些人或者某些应用打扰你）</li>
</ul>
<h2 id="Using-intelligence"><a href="#Using-intelligence" class="headerlink" title="Using intelligence"></a>Using intelligence</h2><h3 id="Live-Text"><a href="#Live-Text" class="headerlink" title="Live Text"></a>Live Text</h3><ul>
<li>可以识别出图片中的文字，不论在网页中，还是相册中，还是正在拍摄中</li>
<li>支持 English、Chinese（简中和繁中）、French、Italian、German、</li>
</ul>
<h3 id="Spanish、Portuguese"><a href="#Spanish、Portuguese" class="headerlink" title="Spanish、Portuguese"></a>Spanish、Portuguese</h3><ul>
<li>也可以识别出图片中的物品、场景和动物等</li>
</ul>
<h3 id="Spotlight"><a href="#Spotlight" class="headerlink" title="Spotlight"></a>Spotlight</h3><ul>
<li>现在可以搜索照片了</li>
<li>也可以通过照片中的文字，地名等搜索照片</li>
</ul>
<h3 id="Photos-Memories"><a href="#Photos-Memories" class="headerlink" title="Photos Memories"></a>Photos Memories</h3><ul>
<li>照片“回忆”加强版，可以自动调整每张照片的滤镜，色调，对比度，让他们看起来一致，还可以调整背景音乐</li>
</ul>
<h2 id="Exploring-the-world"><a href="#Exploring-the-world" class="headerlink" title="Exploring the world"></a>Exploring the world</h2><h3 id="Wallet"><a href="#Wallet" class="headerlink" title="Wallet"></a>Wallet</h3><ul>
<li>金融卡，公交卡，迪士尼，钥匙（车，家），ID card（国内没有），房卡（可显示房号，需要酒店支持）</li>
</ul>
<h3 id="Weather"><a href="#Weather" class="headerlink" title="Weather"></a>Weather</h3><ul>
<li>重新布局，并能够显示更多的信息了</li>
</ul>
<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><ul>
<li>重新布局，增强了道路显示（国外），增强了道路细节（人行横道，立交桥等，仍然是国外），可以显示地标建筑（类似于谷歌地球），</li>
<li>在你找不到方向时，可以扫描周围的街景，使用 AR 导航，带你步行到达目的地（仍然是国外）</li>
</ul>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><ul>
<li>Voice Search in Safari（Safari 语音搜索）</li>
<li>Cross-app drag and drop（不同 app 间的内容拖放）</li>
<li>new outfit options for Memoji（为拟我表情带来全新的装束选项）</li>
</ul>
<h2 id="AirPods"><a href="#AirPods" class="headerlink" title="AirPods"></a>AirPods</h2><ul>
<li>Conversation Boost（为轻微听障人士，支持AirPods Pro)</li>
<li>reduce the amount of ambient noise（降噪）</li>
<li>Announce Notifications（通知播报功能）</li>
<li>可使用 Find My（仅限 AirPods Pro 和 AirPods Max）</li>
<li>增加了遗落提示（防止耳机丢失）</li>
<li>Spatial audio（空间音频）（还是仅限 AirPods Pro 和 AirPods Max）（tvOS 将在秋季引入该功能）（M1 芯片的 MacBook 将引入该功能）</li>
</ul>
<h1 id="iPadOS"><a href="#iPadOS" class="headerlink" title="iPadOS"></a>iPadOS</h1><h3 id="Widgets"><a href="#Widgets" class="headerlink" title="Widgets"></a>Widgets</h3><ul>
<li>可以自由组合小组件</li>
<li>提供了更大尺寸的小组件</li>
</ul>
<h3 id="App-Library（App-库）"><a href="#App-Library（App-库）" class="headerlink" title="App Library（App 库）"></a>App Library（App 库）</h3><ul>
<li>引入了 App Library</li>
<li>可以从 Dock 中进入</li>
</ul>
<h3 id="Multitasking"><a href="#Multitasking" class="headerlink" title="Multitasking"></a>Multitasking</h3><ul>
<li>现在 App 的顶部会出现新的控件，轻点后就可以显示多任务菜单</li>
<li>点击菜单中的分屏浏览图标，当前 App 就会滑动到屏幕侧面，然后选择需要的 App</li>
<li>在分屏状态下切换 App，只需要向下轻扫，然后选择另一款 App 即可</li>
<li>新功能：App 架，里面包含了所有该 App 打开的窗口，包括与其他应用分屏的</li>
</ul>
<h3 id="Notes（备忘录）"><a href="#Notes（备忘录）" class="headerlink" title="Notes（备忘录）"></a>Notes（备忘录）</h3><ul>
<li>可以在共享的备忘录中 @ 某个人了，那个人会收到相应的通知</li>
<li>可以快速查看共享备忘录的改动（历史记录功能）</li>
<li>新增备忘录标签（#someTag）功能，可以对备忘录进行分类</li>
</ul>
<h3 id="Quick-Note（快速备忘录）"><a href="#Quick-Note（快速备忘录）" class="headerlink" title="Quick Note（快速备忘录）"></a>Quick Note（快速备忘录）</h3><ul>
<li>只需要使用 Apple Pencil 从屏幕右下角往左上轻扫即可唤出快速备忘录</li>
<li>它可以识别正在使用的 App，例如 Safari，你在浏览 Safari 的时候打开快速备忘录时，可以很方便地将网络连接加入其中。</li>
<li>当你浏览这个网址的时候，右下角会有提示弹出，点击后会打开有相应链接的备忘录</li>
<li>在你将该网页的某段文本加入到备忘录中后，点击该文本，即可快速移动到网页中的相应位置</li>
<li>并且你也可以添加任何第三方 App 的链接（支持 macOS 和 iPadOS，iOS 仅可以浏览）</li>
</ul>
<h3 id="Tanslate"><a href="#Tanslate" class="headerlink" title="Tanslate"></a>Tanslate</h3><ul>
<li>Auto Translate（同声传译），可以自动监听是否在讲话中，自动检测你说的语言</li>
</ul>
<h3 id="Swift-Playgrounds"><a href="#Swift-Playgrounds" class="headerlink" title="Swift Playgrounds"></a>Swift Playgrounds</h3><ul>
<li>Build apps on your iPad - 可以在 iPad 上开发 iOS App 和 iPad App（使用 Swift UI）</li>
<li>Code completion（自动补全）</li>
<li>Submit to AppStore - 开发完成后可以直接提交到 App Store</li>
</ul>
<h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><h3 id="Mail"><a href="#Mail" class="headerlink" title="Mail"></a>Mail</h3><ul>
<li>Mail Privacy Protection（邮件隐私保护）- 可以隐藏 IP，隐藏位置信息，隐藏你是否及何时打开了邮件</li>
</ul>
<h3 id="Safari"><a href="#Safari" class="headerlink" title="Safari"></a>Safari</h3><ul>
<li>阻止追踪者获取你的 IP，从而隐藏位置信息</li>
<li>生成拦截报告</li>
</ul>
<h3 id="App-Privacy-Report"><a href="#App-Privacy-Report" class="headerlink" title="App Privacy Report"></a>App Privacy Report</h3><ul>
<li>可以查看各个 App 使用了哪些隐私数据，以及何时使用它们的</li>
</ul>
<h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><ul>
<li>Audio never leaves device - 现在可以离线使用了</li>
<li>增加了更多种类的声音</li>
</ul>
<h2 id="iCloud"><a href="#iCloud" class="headerlink" title="iCloud"></a>iCloud</h2><h3 id="Account-Recovery"><a href="#Account-Recovery" class="headerlink" title="Account Recovery"></a>Account Recovery</h3><ul>
<li>可以添加信任的人，在你忘记账号密码时帮助你找回账号</li>
</ul>
<h3 id="Digital-Legacy"><a href="#Digital-Legacy" class="headerlink" title="Digital Legacy"></a>Digital Legacy</h3><ul>
<li>数字遗产，在你过世后可以访问你的账号</li>
</ul>
<h3 id="Private-Relay"><a href="#Private-Relay" class="headerlink" title="Private Relay"></a>Private Relay</h3><ul>
<li>可以通过 Safari 用一种更加安全的方式来访问网络资源，通过对发出的通信进行加密，并通过转接方式加密。</li>
</ul>
<h3 id="Hide-My-Email"><a href="#Hide-My-Email" class="headerlink" title="Hide My Email"></a>Hide My Email</h3><ul>
<li>可以使用一个虚拟的随机的邮箱来接收邮件，它会将收到的邮件转发到你的实际邮箱账号中，并且可以随时删除</li>
</ul>
<h3 id="Homekit-Secure-Video"><a href="#Homekit-Secure-Video" class="headerlink" title="Homekit Secure Video"></a>Homekit Secure Video</h3><h2 id="Health"><a href="#Health" class="headerlink" title="Health"></a>Health</h2><h3 id="Mobility-监测平衡问题和步态障碍"><a href="#Mobility-监测平衡问题和步态障碍" class="headerlink" title="Mobility - 监测平衡问题和步态障碍"></a>Mobility - 监测平衡问题和步态障碍</h3><h3 id="Walking-Steadiness（步行稳定性）"><a href="#Walking-Steadiness（步行稳定性）" class="headerlink" title="Walking Steadiness（步行稳定性）"></a>Walking Steadiness（步行稳定性）</h3><ul>
<li>iPhone 会自动检测行走速度、均匀度、步长、每步用时以及你双脚着地的时间。从而计算出你的平衡性、稳定性和协调性变化，如果这些指标太低，你会收到通知</li>
<li>App 还提供了如何改善这些指标的训练方法</li>
</ul>
<h3 id="Labs"><a href="#Labs" class="headerlink" title="Labs"></a>Labs</h3><ul>
<li>现在会显示更详细的健康数据，并对数据里的指标代表的含义进行说明</li>
</ul>
<h3 id="Trends（趋势）"><a href="#Trends（趋势）" class="headerlink" title="Trends（趋势）"></a>Trends（趋势）</h3><ul>
<li>会显示你的各项指标的走向以便你能够更加了解自己的身体情况</li>
</ul>
<h3 id="Family"><a href="#Family" class="headerlink" title="Family"></a>Family</h3><ul>
<li>获得授权后，可以查看某个家庭成员的健康数据</li>
</ul>
<h2 id="watchOS"><a href="#watchOS" class="headerlink" title="watchOS"></a>watchOS</h2><h3 id="Health-1"><a href="#Health-1" class="headerlink" title="Health"></a>Health</h3><ul>
<li>增强了正念训练（呼吸，沉思）</li>
<li>Respiratory Rate - 睡眠 App 可以跟踪呼吸速率了</li>
<li>增加了两种日常训练：1、太极，2、普拉提训练</li>
<li>Fitness+ 推出了一套新的体能训练</li>
<li>人像表盘</li>
</ul>
<h2 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h2><h3 id="Easy-to-use"><a href="#Easy-to-use" class="headerlink" title="Easy to use"></a>Easy to use</h3><ul>
<li>可以用 HomePod 唤起 Apple TV</li>
<li>HomePod 支持不同人的声音识别</li>
<li>可以将 Siri 集成到第三方设备上了</li>
<li>Matter（一个智能家居行业标准）</li>
</ul>
<h3 id="Better-together"><a href="#Better-together" class="headerlink" title="Better together"></a>Better together</h3><h3 id="Private-and-secure"><a href="#Private-and-secure" class="headerlink" title="Private and secure"></a>Private and secure</h3><h1 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h1><h3 id="Universal-Control（连续互通）"><a href="#Universal-Control（连续互通）" class="headerlink" title="Universal Control（连续互通）"></a>Universal Control（连续互通）</h3><ul>
<li>可以只用一套鼠标和键盘，同时在 MacBook 和 iPad 上使用</li>
<li>可以跨设备拖拽文件</li>
</ul>
<h3 id="AirPlay-to-Mac"><a href="#AirPlay-to-Mac" class="headerlink" title="AirPlay to Mac"></a>AirPlay to Mac</h3><ul>
<li>Mac 先在可以作为隔空播放的目标了</li>
</ul>
<h3 id="Shotcuts（快截指令）"><a href="#Shotcuts（快截指令）" class="headerlink" title="Shotcuts（快截指令）"></a>Shotcuts（快截指令）</h3><h3 id="Safari-1"><a href="#Safari-1" class="headerlink" title="Safari"></a>Safari</h3><ul>
<li>全新的界面，全新的标签页</li>
<li>Extensions - 扩展现在也支持 iPad 和 iPhone 了</li>
</ul>
<h2 id="Developer-Technologies"><a href="#Developer-Technologies" class="headerlink" title="Developer Technologies"></a>Developer Technologies</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li>SharePlay，专注模式，各类通知，语音突显和宽频谱等</li>
<li>Object Capture - 可以通过一系列 2D 图片生成对应的 3D 模型</li>
</ul>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><ul>
<li>Concurrency - async await actor</li>
</ul>
<h3 id="App-Store"><a href="#App-Store" class="headerlink" title="App Store"></a>App Store</h3><ul>
<li>可以创建多个自定义产品页面</li>
<li>可以使用不同的屏幕截图、视频、App图标</li>
<li>展示 App 内开展的动态活动</li>
<li>In-App Events - App 内精彩活动（可以再 App 产品页展示，用户可以订阅以收到活动开始的提醒，也可以直接加入）</li>
</ul>
<h3 id="Xcode-Cloud"><a href="#Xcode-Cloud" class="headerlink" title="Xcode Cloud"></a>Xcode Cloud</h3><ul>
<li>提交代码后，它可以自动编译 app（云端处理），如果失败，所有成员都可以看到出错信息</li>
<li>接着会进行自动化测试（模拟器）</li>
<li>通过后会通过 TestFlight 自动下发测试版（内部测试，外部测试均可），macOS 也会引入 TestFlight App</li>
<li>不会泄露源码</li>
<li>已经开启灰度测试</li>
<li>明年会完全开放</li>
<li>秋季会发布价格（收费的！）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>flutter 2.0新特性</title>
    <url>/2021/03/08/flutter-2-0%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>Flutter 升级到了 2.0。有了很多新特性与改动，简单的总结了一下</p>
<h2 id="一、Web"><a href="#一、Web" class="headerlink" title="一、Web"></a>一、Web</h2><p>Web 支持已经移到 stable 分支，意味着我们可以尝试使用 Flutter 来开发 Web 端的程序了。<br>在 AS 中也可以看到，可以选择 Web 作为 target 。<br>详细内容可以参考 <a href="https://medium.com/flutter/web-post-d6b84e83b425">https://medium.com/flutter/web-post-d6b84e83b425</a></p>
<h2 id="二、空安全（Sound-Null-Safety）"><a href="#二、空安全（Sound-Null-Safety）" class="headerlink" title="二、空安全（Sound Null Safety）"></a>二、空安全（Sound Null Safety）</h2><p>空安全是 Dart 2.12.0 引入的一个新特性，将 可空类型（nullable types）和 不可空类型（non-nullable types）区分开。（类似 Swift Optional Value）<br>Sound Null Safety 官方文档链接 <a href="https://dart.dev/null-safety">https://dart.dev/null-safety</a></p>
<p>Dart 2.12 同时也将 Dart FFI（foreign function interface） 也移入了 stable 分支，通过它可以让 Dart 执行 C语言代码。这样来看，很多库例如 ffmpeg 可能以后也会有 Dart 版本了。<br>Dart 2.12 更新说明 <a href="https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87">https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87</a></p>
<h2 id="三、Desktop"><a href="#三、Desktop" class="headerlink" title="三、Desktop"></a>三、Desktop</h2><p>Flutter Desktop（Windows，macOS，Linux） 虽然移至了 stable 中，但是相当于一个先行版本，更稳定的版本将在今年晚些放出。<br>you can think of it as a “beta snapshot” that previews the final stable release coming later this year.</p>
<p>想要在 macOS 下运行，首先查看是否配置了对应选项<br>执行 flutter config <br><img src="/2021/03/08/flutter-2-0%E6%96%B0%E7%89%B9%E6%80%A7/1.jpg"><br>通过这些参数，开启对应端的 target。<br>查看输出是否有<br><img src="/2021/03/08/flutter-2-0%E6%96%B0%E7%89%B9%E6%80%A7/2.jpg"><br>如果为空，执行 flutter config –enable-macos-desktop，然后 flutter devices 就会列出 macos 了。<br><img src="/2021/03/08/flutter-2-0%E6%96%B0%E7%89%B9%E6%80%A7/3.png"><br>然后执行代码 flutter run -d macos<br><img src="/2021/03/08/flutter-2-0%E6%96%B0%E7%89%B9%E6%80%A7/4.jpg"><br>如果出现这种情况，说明没有生成对应的工程文件，需要执行一下<br>flutter create –platforms macos .<br>然后再执行<br>flutter run -d macos<br>即可成功运行</p>
<p>但如果你需要及时的获得更新或者 bug 修复，官方还是建议移至 beta 或者 dev 分支去。<br>However, if you choose to stay on the stable channel to access the desktop beta, you won’t get new features or bug fixes as quickly as switching to the beta or dev channels. So, if you’re actively targeting Windows, macOS, or Linux, we recommend switching to a channel that provides updates more quickly.</p>
<h2 id="四、Platform-Adaptive-Apps-Flutter-Folio-Sample"><a href="#四、Platform-Adaptive-Apps-Flutter-Folio-Sample" class="headerlink" title="四、Platform Adaptive Apps: Flutter Folio Sample"></a>四、Platform Adaptive Apps: Flutter Folio Sample</h2><p>现在 Flutter 支持六个端（包括 beta）iOS、Android、Web、Windows、macOS、Linux，如何才能为 App 做适配，让它支持<br>1）各种输入（鼠标，触摸、键盘）<br>2）不同屏幕尺寸<br>3）不同平台（手机，桌面，Web）<br>于是 Flutter 退出了 Folio 这个示例 App 供开发者学习<br>项目地址：<a href="https://github.com/gskinnerTeam/flutter-folio">https://github.com/gskinnerTeam/flutter-folio</a></p>
<h2 id="五、Google-Mobile-Ads（beta）"><a href="#五、Google-Mobile-Ads（beta）" class="headerlink" title="五、Google Mobile Ads（beta）"></a>五、Google Mobile Ads（beta）</h2><h2 id="六、iOS新功能"><a href="#六、iOS新功能" class="headerlink" title="六、iOS新功能"></a>六、iOS新功能</h2><p>解决的重要 Issue<br>23495<br>67781<br>69809</p>
<h2 id="新增的-Widget"><a href="#新增的-Widget" class="headerlink" title="新增的 Widget"></a>新增的 Widget</h2><p>CupertinoSearchTextField<br>CupertinoFormSection<br>CupertinoFormRow<br>CupertinoTextFormFieldRow</p>
<h2 id="七、新-Widget"><a href="#七、新-Widget" class="headerlink" title="七、新 Widget"></a>七、新 Widget</h2><p>Autocomplete<br>ScaffoldMessenger</p>
<h2 id="八、Multiple-Flutter-instances-with-Add-to-App"><a href="#八、Multiple-Flutter-instances-with-Add-to-App" class="headerlink" title="八、Multiple Flutter instances with Add-to-App"></a>八、Multiple Flutter instances with Add-to-App</h2><p>创建多个 Flutter Instance 时，在过去，额外的 Flutter 实例消耗内存的数量与第一个一样，现在，额外的 Flutter 实例消耗内存的数量大大降低。<br>本以为有了 FlutterEngineGroup 这个类，通过 FlutterEngineGroup.makeNewEngine 实例化的 FlutterEngine 对象共享运行时环境，后来查看 Demo 发现，他们的运行时环境仍然是独立的。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter AnimatedList</title>
    <url>/2021/03/24/flutter-AnimatedList/</url>
    <content><![CDATA[<p>今天学习了 AnimatedList 的使用方法，通过它可以为 添加和移除 list cell 两个动作添加动画，具体使用方法如下</p>
<h3 id="1、创建-GlobalKey"><a href="#1、创建-GlobalKey" class="headerlink" title="1、创建 GlobalKey"></a>1、创建 GlobalKey</h3><p>创建一个 GlobalKey，用来获取 AnimatedListState 对象</p>
<pre><code class="dart">GlobalKey&lt;AnimatedListState&gt; key = GlobalKey&lt;AnimatedListState&gt;();
</code></pre>
<h3 id="2、创建-Cell-Builder-方法"><a href="#2、创建-Cell-Builder-方法" class="headerlink" title="2、创建 Cell Builder 方法"></a>2、创建 Cell Builder 方法</h3><p>创建一个 ListCell 的 builder 方法，它需要接收一个 animation 参数用来播放动画</p>
<pre><code class="dart">Widget _buildItem(BuildContext context, int index, Animation&lt;double&gt; animation) &#123;
  return ScaleTransition(
    scale: animation,
    child: Container(
      decoration: BoxDecoration(
        color: Colors.lightGreen,
        border: Border.all(color: Colors.red),
      ),
      height: 44,
      margin: EdgeInsets.all(8),
      child: Center(
        child: Text(&#39;$index&#39;),
      ),
    ),
  );
&#125;
</code></pre>
<h3 id="3、添加-add-与-remove-方法用来增删-Cell"><a href="#3、添加-add-与-remove-方法用来增删-Cell" class="headerlink" title="3、添加 _add 与 _remove 方法用来增删 Cell"></a>3、添加 _add 与 _remove 方法用来增删 Cell</h3><p>接着，你需要两个按钮，一个用来 add cell，一个用来 delete cell，他们的点击方法分别是，其中 count 是列表中 cell 的数量。</p>
<pre><code class="dart">_add() &#123;
  key.currentState.insertItem(count);
  count++;
&#125;

_remove() &#123;
  key.currentState.removeItem(count - 1, (_, __) =&gt; _buildItem(_, count, __));
  count--;
&#125;
</code></pre>
<h3 id="4、创建-AnimatedList-列表"><a href="#4、创建-AnimatedList-列表" class="headerlink" title="4、创建 AnimatedList 列表"></a>4、创建 AnimatedList 列表</h3><p>最后只需要创建一个 AnimatedList 即可</p>
<pre><code class="dart">AnimatedList(
  key: key,
  itemBuilder: _buildItem,
)
</code></pre>
<p>关键点，removeItem 方法执行后，指定 index 处的 cell widget 会立刻移除。</p>
<p>为了显示动画，所以提供了一个 builder 方法用来创建一个新的 Widget 用来播放移除动画，该方法提供了一个 animation 参数，它是从 1 -&gt; 0 变化的，与 itemBuilder 中提供的相反。</p>
<p>所以只需要提供相同的构造方法，即可创建与显示动画相反的消失动画。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter Draggable 和 DragTarget 和 IntrinsicHeight</title>
    <url>/2021/04/07/flutter-Draggable-%E5%92%8C-DragTarget-%E5%92%8C-IntrinsicHeight/</url>
    <content><![CDATA[<h3 id="1、Draggable-和-DragTarget"><a href="#1、Draggable-和-DragTarget" class="headerlink" title="1、Draggable 和 DragTarget"></a>1、Draggable 和 DragTarget</h3><p>作品编辑页，画面列表调整功能，主要使用 <strong>Draggable</strong> 和 <strong>DragTarget</strong> 两个类，第一个用来实现拖出来的效果，第二个用来实现放入的效果，</p>
<p>Draggable 有四个参数比较重要 child、feedback、childWhenDragging、data。</p>
<ul>
<li><strong>child</strong> - 默认状态下显示的组件</li>
<li><strong>feedback</strong> - 拖动状态下，跟随手指移动的组件</li>
<li><strong>childWhenDragging</strong> - 顾名思义，是指拖动状态下，原来的地方显示的组件，如果不赋值，则默认使用 child</li>
<li><strong>data</strong> - 配合 DragTarget 使用的，可以将其传入 DragTarget 中</li>
</ul>
<p>DragTarget 有三个参数比较重要 builder、onWillAccept、onAccept</p>
<ul>
<li><strong>builder - Widget Function(BuildContext context, List&lt;T?&gt; candidateData, List<dynamic> rejectedData)</strong><br>只要拖动 Draggable 经过它就会调用，其中 candidateData 和 rejectedData 的内容就是 Draggable 的 data 属性，只不过如果 onWillAccept 返回 true 的时候，它位于 candidateData 中，返回 false 则位于 rejectedData 中。</li>
<li><strong>onWillAccept - bool Function(T data)</strong> <br>只要拖动 Draggable 经过它就会调用，判断这个数据是否是该 Target 感兴趣，需要处理的，如果返回 false，onAccept 不会调用</li>
<li><strong>onAccept</strong> - 将 Draggable 拖动到该组件释放时，可能会调用，具体取决于 onWillAccept 返回的值。</li>
</ul>
<h3 id="2、IntrinsicHeight-–-一个可以将-child-的尺寸改为它本身的大小的小组件。"><a href="#2、IntrinsicHeight-–-一个可以将-child-的尺寸改为它本身的大小的小组件。" class="headerlink" title="2、IntrinsicHeight – 一个可以将 child 的尺寸改为它本身的大小的小组件。"></a>2、IntrinsicHeight – 一个可以将 child 的尺寸改为它本身的大小的小组件。</h3><p>在指定了 BoxConstrains 的情况下不起作用，例如<br><img src="/2021/04/07/flutter-Draggable-%E5%92%8C-DragTarget-%E5%92%8C-IntrinsicHeight/1.jpg"><br><img src="/2021/04/07/flutter-Draggable-%E5%92%8C-DragTarget-%E5%92%8C-IntrinsicHeight/2.jpg"><br>￼<br>Column 中的使用方法，Container 不再填充至整个 Column，而是限制在了 text 本身的高度。<br><img src="/2021/04/07/flutter-Draggable-%E5%92%8C-DragTarget-%E5%92%8C-IntrinsicHeight/3.jpg"><br><img src="/2021/04/07/flutter-Draggable-%E5%92%8C-DragTarget-%E5%92%8C-IntrinsicHeight/4.jpg"><br>￼<br>￼</p>
]]></content>
  </entry>
  <entry>
    <title>flutter ReorderableListView</title>
    <url>/2021/04/25/flutter-ReorderableListView/</url>
    <content><![CDATA[<p>今天接触到了一个新的 Widget</p>
<p><strong>ReorderableListView</strong></p>
<p>是一个可拖动的排序列表</p>
<ul>
<li>优点是，其中的动画和其他的工作系统已经帮我们完成了，只需要传入 children 和 onReorder 两个参数即可使用。</li>
<li>缺点是，默认所有的 cell 都是可以拖动排序的，无法单独设置，想要设置还有点麻烦，得改改写这个组件才行。</li>
</ul>
<p>这里附上一个简单的 Demo，有兴趣的可以跑一下看看效果</p>
<pre><code class="dart">final List&lt;int&gt; _items = List&lt;int&gt;.generate(50, (int index) =&gt; index);
Widget build(BuildContext context)&#123;
  final ColorScheme colorScheme = Theme.of(context).colorScheme;
  final oddItemColor = colorScheme.primary.withOpacity(0.05);
  final evenItemColor = colorScheme.primary.withOpacity(0.15);
  return ReorderableListView(
    padding: const EdgeInsets.symmetric(horizontal: 40),
    children: &lt;Widget&gt;[
      for (int index = 0; index &lt; _items.length; index++)
        ListTile(
          key: Key(&#39;$index&#39;),
          tileColor: _items[index].isOdd ? oddItemColor : evenItemColor,
          title: Text(&#39;Item $&#123;_items[index]&#125;&#39;),
        ),
    ],
    onReorder: (int oldIndex, int newIndex) &#123;
      setState(() &#123;
        if (oldIndex &lt; newIndex) &#123;
          newIndex -= 1;
        &#125;
        final int item = _items.removeAt(oldIndex);
        _items.insert(newIndex, item);
      &#125;);
    &#125;,
  );
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>flutter UI与业务逻辑分离</title>
    <url>/2022/07/07/flutter-UI%E4%B8%8E%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<p>今天将 MyProductPageController 中到的 Network 和 UseCase 剥离了出来，作为 Repository 和 UseCase，这样有了三个类，Controller、UseCase 和 Repositorry 三个类。他们各自的作用是：<br>Controller - 作为 UI 层的处理，用于将用户的交互事件与 UseCase 对应起来<br>UseCase - 用户交互的抽象类，仅包含数据的处理，但不包含数据的获取<br>Repository - 会作为依赖注入到 UseCase 中去，通过它来获取相应的数据，这里是用户的作品列表和回收站列表数据。<br>这样，用户的交互就变成了<br><img src="/2022/07/07/flutter-UI%E4%B8%8E%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB/1.png"></p>
<p>其中 UseCase 作为参数传入 Controller 中，Repository 作为依赖注入到每一个 UseCase 中，UseCase 通过它来进行数据的获取，这样就完成了逻辑与 UI 分离。<br>可以注意到，Widget + Controller 作为表示层，剩余的三个作为逻辑层，已经不再是强耦合，同样的逻辑，你换一个 UI 和 Controllerr，只要将 UseCase 作为参数传入新的 Controller 中，同样可以使用原有的逻辑。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter UI调试</title>
    <url>/2021/08/30/flutter-UI%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>关于 flutter 中的 mixin Diagnosticable，flutter 我们最常用的就是 Widget，它是继承自 DiagnosticableTree 类，而 DiagnosticableTree 使用 Diagnosticable，首先我们看看 Diagnosticable。</p>
<p>顾名思义，它应该是提供诊断信息的一个 mixin，从它提供的四个方法中就可以看出，它们分别是</p>
<pre><code class="dart">String toStringShort()
String toString(&#123; DiagnosticLevel minLevel = DiagnosticLevel.info &#125;)
DiagnosticsNode toDiagnosticsNode(&#123; String? name, DiagnosticsTreeStyle? style &#125;)
void debugFillProperties(DiagnosticPropertiesBuilder properties)
</code></pre>
<p>其中 <strong>void debugFillProperties(DiagnosticPropertiesBuilder properties)</strong> 方法可以为我们添加自定义属性用于调试，例如：<br><img src="/2021/08/30/flutter-UI%E8%B0%83%E8%AF%95/1.jpg"><br>￼<br>这里实现了一个最简单的自定义 Widget，它啥也不能显示，但是可以用来验证 debugFillProperty 方法的作用。</p>
<p>这里添加了一个自定义调试属性 seven 它的值是 77777.0。运行 App，打开 DevTools，<br><img src="/2021/08/30/flutter-UI%E8%B0%83%E8%AF%95/2.jpg"><br>￼<br>可以看到有一个 MyWidget，正是我们的自定义 Widget ，点一下它<br><img src="/2021/08/30/flutter-UI%E8%B0%83%E8%AF%95/3.jpg"></p>
<p>就可以看到我们自己添加的调试属性了</p>
]]></content>
  </entry>
  <entry>
    <title>flutter 单元测试</title>
    <url>/2022/05/13/flutter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>有时候，会需要对那些获取网络数据或者数据库数据的方法或者类进行测试，这会有以下几点不便：</p>
<ol>
<li>会延长单元测试的时间</li>
<li>已经通过了的测试可能会由于服务端返回了别的信息而导致失败</li>
<li>没有办法测试所有的情况</li>
</ol>
<p>所以为了方便测试，与其依赖网络请求或者数据库读取，我们需要自己“mock”一个依赖，这只需要三个步骤：</p>
<ol>
<li>添加依赖库</li>
<li>创建单元测试文件，生成‘mock’依赖</li>
<li>编写单元测试</li>
</ol>
<h3 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h3><p>打开 pubspec.yaml 假如如下代码</p>
<pre><code class="yaml">dependencies:
  dio: &lt;newest_version&gt;
dev_dependencies:
  flutter_test:
    sdk: flutter
  mockito: &lt;newest_version&gt;
  build_runner: &lt;newest_version&gt;
</code></pre>
<h3 id="创建单元测试文件，生成‘mock’依赖"><a href="#创建单元测试文件，生成‘mock’依赖" class="headerlink" title="创建单元测试文件，生成‘mock’依赖"></a>创建单元测试文件，生成‘mock’依赖</h3><p>当前需要测试的是 fontUtils 类，所以我们创建一个测试文件，命名为 font_utils_test.dart，并输入以下内容。</p>
<pre><code class="dart">import &#39;package:dio/dio.dart&#39;;
import &#39;package:mockito/annotations.dart&#39;;

@GenerateMocks([Dio])
void main() &#123;&#125;
</code></pre>
<p>然后运行 flutter pub run build_runner build，等待完成后，就生成了一个 MockDio，我们可以通过它来模拟网络请求了。</p>
<h3 id="编写单元测试"><a href="#编写单元测试" class="headerlink" title="编写单元测试"></a>编写单元测试</h3><p>以获取字体列表接口为例，我们首先需要构造一个正常的返回值，用 Postman 存一个即可，保存到ttf_list.json 文件中，全部代码如下</p>
<pre><code class="dart">@GenerateMocks([Dio])
void main() &#123;
  test(&#39;query font info success&#39;, () async &#123;
    // 创建一个 mock 网络请求类，它拥有和 Dio 一样的 api
    final client = MockDio(); 

        // 构造的返回值文件地址
    final root = Directory.current.path;
    const filePath = &#39;test/utils_test/ttf_list.json&#39;;
    
    // 网络请求地址
    const base = &#39;https://gwdev.aoscdn.com/app/lightmv&#39;;
    const path = &#39;/font-manage/font-libraries-list&#39;;
    
    // 使用 when 方法来 mock 一个网络请求，使用后续使用 client.get 时
    // 会按照 thenAnswer 中所写的进行返回
    when(client.get(&#39;$base$path&#39;)).thenAnswer(
      (_) async &#123;
        return Response(
          requestOptions: RequestOptions(path: path),
          data: File(&#39;$root/$filePath&#39;).readAsStringSync(),
          statusCode: 200,
        );
      &#125;,
    );

        // 使用 mock dio 进行网络请求
    final res = await client.get(&#39;$base$path&#39;);
    Map json = jsonDecode(res.data);
    
    // 这部分还需要加上相应的测试逻辑
    expect(json, isA&lt;Map&gt;());
  &#125;);
&#125;
</code></pre>
<p>至此，一个带有网络请求的单元测试已经编写完成，后续可以再加上相应的逻辑进行，来验证例如分别返回正常数据和异常数据时，工具类处理方式是否正确。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter 单元测试应用于字体下载功能</title>
    <url>/2022/05/17/flutter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BA%94%E7%94%A8%E4%BA%8E%E5%AD%97%E4%BD%93%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>这短时间看了不少关于单元测试的知识，正好到了一个新的版本，可以验证一下目前所学了。</p>
<p>首先回顾一下写单元测试目的，它是通过对程序的每一个独立的部分进行验证，从而确保程序的正确性。这样就要求我们对程序进行合理的代码设计，尽量可以去独立的验证，它类似linux的宗旨，每一个功能就做一件事情，并且做好。</p>
<p>这需要我们对现有程序进行功能上的拆分，保证每一个函数只完成一个功能，听起来虽然简单，但是实际做起来却有点复杂，</p>
<p>以目前右糖的字体下载作为举例，按照先前学到的内容，首先我们需要对它的功能进行需求分解，将它分解成一个一个单一的任务：</p>
<ol>
<li>下载字体，这个是最主要的功能</li>
<li>还需要检查字体是否已下载，防止字体重复下载，浪费网络资源</li>
<li>使用字体</li>
<li>这三个是主要功能，但仍然没有达到单一任务的原则，还需要继续划分</li>
</ol>
<p>通过拆分，可以得到 7 个基本功能，需要注意的是：</p>
<p>第七条不属于单元测试，它属于 UI 测试的范畴，这个后续还需要进行学习。</p>
<p>第三条后面标注了两个来源，这个可以通过依赖注入实现，实际上就是通过提供不同的数据源来进行测试。<br><img src="/2022/05/17/flutter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BA%94%E7%94%A8%E4%BA%8E%E5%AD%97%E4%BD%93%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/1.png"><br>￼<br>这样就完成了一个简单的功能拆分，基本达到了单一任务的原则，当然我们还有很多地方可以进行优化，在后续的开发过程中，也可以随时对它进行扩充。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter 圆角边框</title>
    <url>/2022/03/28/flutter-%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/</url>
    <content><![CDATA[<p>今天在视觉还原的时候遇到了一个问题，flutter 如何在裁剪的同时，设置一个贴合边缘的边框。</p>
<p>一开始想到的方案是使用 Container.decoration 属性来完成，通过提供一个设置了圆角和 BoxDecoration 对象来实现。</p>
<p>但是如果 Container.child 是一张图片，图片是不会被裁减的，所以需要换一种实现方式，效果对比如下<br><img src="/2022/03/28/flutter-%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/1.jpg"></p>
<p>代码如下</p>
<pre><code class="dart">Container(
  foregroundDecoration: BoxDecoration(
    border: Border.all(color: Colors.red, width: 2),
    borderRadius: BorderRadius.circular(16),
  ),
  child: ClipRRect(
    borderRadius: BorderRadius.circular(16),
    child: _image(),
  ),
)
</code></pre>
<p>通过 foregroundDecoration 来设置圆角边框，通过 ClipRRect 来裁剪圆角图片，即可实现该效果。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter“视差”列表的实现方式</title>
    <url>/2021/11/01/flutter%E2%80%9C%E8%A7%86%E5%B7%AE%E2%80%9D%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>今天学习了带有视差效果的列表的实现方式，感觉思路又被拓宽了一点，效果如下<br><img src="/2021/11/01/flutter%E2%80%9C%E8%A7%86%E5%B7%AE%E2%80%9D%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/1.gif"></p>
<p>首先进行一下分析，这个画面里有一个列表，每个列表项由一张图片和若干文字组成。可以看到，列表向上滑动时，每个列表项的图片在向下偏移，而且随着滑动距离的变大，偏移量也在变大；对于相反的滑动方向，也是一样。</p>
<p>如果我们想实现这样的效果，只需要计算出每个列表项里面图片的偏移量，图片的偏移量实际上是由列表项在滚动视界的位置计算出来的，越靠上，偏移量越大，越靠下，偏移量越小。核心代码如下</p>
<pre><code class="dart">@override
void paintChildren(FlowPaintingContext context) &#123;
  /// 计算出列表项的偏移量
  final scrollableBox = scrollable.context.findRenderObject() as RenderBox;
  final listItemBox = listItemContext.findRenderObject() as RenderBox;
  final listItemOffset = listItemBox.localToGlobal(
    listItemBox.size.centerLeft(Offset.zero),
    ancestor: scrollableBox,
  );

  /// 计算出偏移百分比，（偏移量 / 滚动控件高度）
  final viewportDimension = scrollable.position.viewportDimension;
  final scrollFraction = (listItemOffset.dy / viewportDimension).clamp(0.0, 1.0);

  /// 转换为 Alignment
  /// 0.0 对应 Alignment(0.0, -1.0) 即 Alignment.topCenter，1.0 对应 Alignment(0.0, 1.0) 即 Alignment.bottomCenter
  final verticalAlignment = Alignment(0.0, scrollFraction * 2 - 1);

  /// 将 Alignment 转换成对应的 Rect
  final backgroundSize = (backgroundImageKey.currentContext!.findRenderObject() as RenderBox).size;
  final listItemSize = context.size;
  final childRect = verticalAlignment.inscribe(
    backgroundSize,
    Offset.zero &amp; listItemSize,
  );

  /// 绘制子控件
  context.paintChild(
    0,
    transform: Transform.translate(
      offset: Offset(0.0, childRect.top),
    ).transform,
  );
&#125;
</code></pre>
<p>paintChildren 是 FlowDelegate 中的一个方法，用来绘制 Flow 控件的 children 列表，通过这个方式，我们可以自定义子控件的布局方式，只需要给每个子控件设置一个 Transform 即可，非常的灵活。</p>
<p>其中比较重要的点有如下几个</p>
<ol>
<li>scrollable 参数是通过 Scrollable.of 方法获取到并传进来的，通过它可以获取到最近一级的滚动控件的 State 对象，其内部原理可以参考 InheritedWidget。</li>
</ol>
<pre><code class="dart">scrollable = Scrollable.of(context);
</code></pre>
<ol start="2">
<li>通过 Offset &amp; Size 来创建一个 Rect 对象.</li>
</ol>
<pre><code class="dart">// 例如 
final rect = Offset.zero &amp; Size(100, 200);
// 等同于 
final rect = Rect.fromLTRB(0, 0, 100, 100);
</code></pre>
<ol start="3">
<li>Alignment.inscribe 方法，该方法接收一个 Size 参数和一个 Rect 参数，通过使用指定的 Alignment，将 size 放于 rect 后，获得新的 rect，举几个列子</li>
</ol>
<pre><code class="dart">final res = Alignment.center.inscribe(Size(100, 100), Rect.fromLTRB(50, 50, 100, 100));
print(res); // Rect.fromLTRB(25.0, 25.0, 125.0, 125.0)
</code></pre>
<p><img src="/2021/11/01/flutter%E2%80%9C%E8%A7%86%E5%B7%AE%E2%80%9D%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/1.png"></p>
<pre><code class="dart">final res = Alignment.topCenter.inscribe(Size(100, 100), Rect.fromLTRB(50, 50, 100, 100));
print(res); // Rect.fromLTRB(25.0, 50.0, 125.0, 150.0)
</code></pre>
<p><img src="/2021/11/01/flutter%E2%80%9C%E8%A7%86%E5%B7%AE%E2%80%9D%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/2.png"></p>
<pre><code class="dart">final res = Alignment.bottomRight.inscribe(Size(50, 50), Rect.fromLTRB(100, 100, 200, 200));
print(res); // Rect.fromLTRB(150.0, 150.0, 200.0, 200.0)
</code></pre>
<p><img src="/2021/11/01/flutter%E2%80%9C%E8%A7%86%E5%B7%AE%E2%80%9D%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/3.png"></p>
<pre><code class="dart">final res = Alignment.topLeft.inscribe(Size(50, 50), Rect.fromLTRB(100, 100, 200, 200));
print(res); // Rect.fromLTRB(100.0, 100.0, 150.0, 150.0)
</code></pre>
<p><img src="/2021/11/01/flutter%E2%80%9C%E8%A7%86%E5%B7%AE%E2%80%9D%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/4.png"></p>
<p>完整代码如下</p>
<pre><code class="dart">import &#39;package:flutter/material.dart&#39;;

class CreateParallaxEffectPage extends StatefulWidget &#123;
  static String rName = &#39;CreateParallaxEffectPage&#39;;
  const CreateParallaxEffectPage(&#123;Key? key&#125;) : super(key: key);

  @override
  _CreateParallaxEffectPageState createState() =&gt; _CreateParallaxEffectPageState();
&#125;

class _CreateParallaxEffectPageState extends State&lt;CreateParallaxEffectPage&gt; &#123;
  @override
  Widget build(BuildContext context) &#123;
    return Scaffold(
      appBar: _buildAppBar(),
      body: _buildBody(),
    );
  &#125;

  PreferredSizeWidget _buildAppBar() &#123;
    return AppBar(title: Text(&#39;Parallax Effect Demo&#39;), elevation: 0.0);
  &#125;

  Widget _buildBody() &#123;
    return ParallaxRecipe();
  &#125;
&#125;

class ParallaxRecipe extends StatelessWidget &#123;
  const ParallaxRecipe(&#123;Key? key&#125;) : super(key: key);

  @override
  Widget build(BuildContext context) &#123;
    return SingleChildScrollView(
      child: Column(
        children: [
          for (final location in locations)
            LocationListItem(
              imageUrl: location.imageUrl,
              name: location.name,
              country: location.place,
            ),
        ],
      ),
    );
  &#125;
&#125;

class LocationListItem extends StatelessWidget &#123;
  LocationListItem(&#123;
    Key? key,
    required this.imageUrl,
    required this.name,
    required this.country,
  &#125;)  : _backgroundImageKey = GlobalKey(),
        super(key: key);

  final String imageUrl;
  final String name;
  final String country;

  final GlobalKey _backgroundImageKey;

  @override
  Widget build(BuildContext context) &#123;
    return Container(
      padding: EdgeInsets.symmetric(horizontal: 24.0, vertical: 16.0),
      child: AspectRatio(
        aspectRatio: 16.0 / 9.0,
        child: ClipRRect(
          borderRadius: BorderRadius.circular(16.0),
          child: Stack(
            children: [
              _buildParallaxBackground(context),
              _buildGradient(),
              _buildTitleAndSubtitle(),
            ],
          ),
        ),
      ),
    );
  &#125;

  Widget _buildParallaxBackground(BuildContext context) &#123;
    return Flow(
      delegate: ParallaxFlowDelegate(
        scrollable: Scrollable.of(context)!,
        listItemContext: context,
        backgroundImageKey: _backgroundImageKey,
      ),
      children: [
        Image.network(
          imageUrl,
          fit: BoxFit.cover,
          key: _backgroundImageKey,
        ),
      ],
    );
  &#125;

  Widget _buildGradient() &#123;
    return Positioned.fill(
      child: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [Colors.transparent, Colors.black.withOpacity(0.7)],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            stops: [0.6, 0.95],
          ),
        ),
      ),
    );
  &#125;

  Widget _buildTitleAndSubtitle() &#123;
    return Positioned(
      left: 20.0,
      bottom: 20.0,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            name,
            style: TextStyle(
              color: Colors.white,
              fontSize: 20.0,
              fontWeight: FontWeight.bold,
            ),
          ),
          Text(
            country,
            style: TextStyle(
              color: Colors.white,
              fontSize: 14.0,
            ),
          ),
        ],
      ),
    );
  &#125;
&#125;

class ParallaxFlowDelegate extends FlowDelegate &#123;
  ParallaxFlowDelegate(&#123;
    required this.scrollable,
    required this.listItemContext,
    required this.backgroundImageKey,
  &#125;) : super(repaint: scrollable.position);

  final ScrollableState scrollable;
  final BuildContext listItemContext;
  final GlobalKey backgroundImageKey;

  @override
  BoxConstraints getConstraintsForChild(int i, BoxConstraints constraints) &#123;
    return BoxConstraints.tightFor(
      width: constraints.maxWidth,
    );
  &#125;

  @override
  void paintChildren(FlowPaintingContext context) &#123;
    /// 计算出列表项的偏移量
    final scrollableBox = scrollable.context.findRenderObject() as RenderBox;
    final listItemBox = listItemContext.findRenderObject() as RenderBox;
    final listItemOffset = listItemBox.localToGlobal(
      listItemBox.size.centerLeft(Offset.zero),
      ancestor: scrollableBox,
    );

    /// 计算出偏移百分比，（偏移量 / 滚动控件高度）
    final viewportDimension = scrollable.position.viewportDimension;
    final scrollFraction = (listItemOffset.dy / viewportDimension).clamp(0.0, 1.0);

    /// 转换为 Alignment
    /// 0.0 对应 Alignment(0.0, -1.0) 即 Alignment.topCenter，1.0 对应 Alignment(0.0, 1.0) 即 Alignment.bottomCenter
    final verticalAlignment = Alignment(0.0, scrollFraction * 2 - 1);

    /// 将 Alignment 转换成对应的 Rect
    final backgroundSize = (backgroundImageKey.currentContext!.findRenderObject() as RenderBox).size;
    final listItemSize = context.size;
    final childRect = verticalAlignment.inscribe(
      backgroundSize,
      Offset.zero &amp; listItemSize,
    );

    /// 绘制子控件
    context.paintChild(
      0,
      transform: Transform.translate(
        offset: Offset(0.0, childRect.top),
      ).transform,
    );
  &#125;

  @override
  bool shouldRepaint(covariant ParallaxFlowDelegate oldDelegate) &#123;
    return scrollable != oldDelegate.scrollable || listItemContext != oldDelegate.listItemContext || backgroundImageKey != oldDelegate.backgroundImageKey;
  &#125;
&#125;

class Location &#123;
  const Location(&#123;
    required this.name,
    required this.place,
    required this.imageUrl,
  &#125;);

  final String name;
  final String place;
  final String imageUrl;
&#125;

const urlPrefix = &#39;https://flutter.dev/docs/cookbook/img-files/effects/parallax&#39;;
const locations = [
  Location(
    name: &#39;Mount Rushmore&#39;,
    place: &#39;U.S.A&#39;,
    imageUrl: &#39;$urlPrefix/01-mount-rushmore.jpg&#39;,
  ),
  Location(
    name: &#39;Gardens By The Bay&#39;,
    place: &#39;Singapore&#39;,
    imageUrl: &#39;$urlPrefix/02-singapore.jpg&#39;,
  ),
  Location(
    name: &#39;Machu Picchu&#39;,
    place: &#39;Peru&#39;,
    imageUrl: &#39;$urlPrefix/03-machu-picchu.jpg&#39;,
  ),
  Location(
    name: &#39;Vitznau&#39;,
    place: &#39;Switzerland&#39;,
    imageUrl: &#39;$urlPrefix/04-vitznau.jpg&#39;,
  ),
  Location(
    name: &#39;Bali&#39;,
    place: &#39;Indonesia&#39;,
    imageUrl: &#39;$urlPrefix/05-bali.jpg&#39;,
  ),
  Location(
    name: &#39;Mexico City&#39;,
    place: &#39;Mexico&#39;,
    imageUrl: &#39;$urlPrefix/06-mexico-city.jpg&#39;,
  ),
  Location(
    name: &#39;Cairo&#39;,
    place: &#39;Egypt&#39;,
    imageUrl: &#39;$urlPrefix/07-cairo.jpg&#39;,
  ),
];
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>flutter中的key</title>
    <url>/2021/10/28/flutter%E4%B8%AD%E7%9A%84key/</url>
    <content><![CDATA[<p>首先 fluttrer 里有很多种类的 key，但是基本可以分为两种：Local Key 和 Global Key</p>
<p>所有不是 GlobalKey 的都属于 LocalKey，例如 Key，ValueKey，UniqueKey，ObjectKey 等等，它们都属于 LocalKey。</p>
<p>key 的作用有很多，对于 GlobalKey，顾名思义，它相对于 Widget Tree 是全局的，这意味着，通过它我们在 Widget Tree 的任意位置访问持有它的 StatefulWidget 的 State 对象，</p>
<p>key 还有一个关键作用，用来标记 Widget、Element 和 SemanticsNode。</p>
<ol>
<li>我们知道 Flutter 中有两棵树，一棵是 Widget Tree，一棵是依照 Widget Tree 生成的对应的 Element Tree。</li>
<li>我们还知道 Widget 相当于一个“蓝图”，系统会将其“填充”成为一个最终显示的 Element</li>
</ol>
<p>举一个简单的例子，如下图所示，<br><img src="/2021/10/28/flutter%E4%B8%AD%E7%9A%84key/1.jpg"></p>
<p>系统通过左边的 Widget Tree 生成了右边对应的 Element Tree，它里面就包含了实际应该显示的数据。假设现在我有一个列表，里面有很多相同类型的 Widget，用来显示颜色，我想将第一项和第二项换一下位置，会出现什么样子的状况呢。 </p>
<p>状况就是颜色并没有发生改变。<br><img src="/2021/10/28/flutter%E4%B8%AD%E7%9A%84key/2.jpg"></p>
<p>因为列表项是同一种 widget，系统发现新的 Widget Tree没有发生变化，而且 Element Tree 中的元素也能够一一对应，所以它不会更新UI，这个时候就需要 key 来帮忙了。<br><img src="/2021/10/28/flutter%E4%B8%AD%E7%9A%84key/3.jpg"></p>
<p>我们给对应的列表项添加一个 UniqueKey()，如图所示，接着再进行调换位置。<br><img src="/2021/10/28/flutter%E4%B8%AD%E7%9A%84key/4.jpg"></p>
<p>这个时候系统发现 Widget Tree 和 Elment Tree 没法一一对应了，但是仍然能够找到与其匹配的 Element，所以系统将 Element Tree 中的红色和黑色列表项调换了位置，于是 UI 发生了改变，成功地切换了颜色。</p>
<p>代码如下</p>
<pre><code class="dart">import &#39;package:flutter/material.dart&#39;;

class ListViewDemoPage extends StatefulWidget &#123;
  static String rName = &#39;ListViewDemoPage&#39;;
  const ListViewDemoPage(&#123;Key? key&#125;) : super(key: key);

  @override
  _ListViewDemoPageState createState() =&gt; _ListViewDemoPageState();
&#125;

class _ListViewDemoPageState extends State&lt;ListViewDemoPage&gt; &#123;
  List&lt;Color&gt; colors = [
    Colors.red,
    Colors.green,
  ];

  @override
  Widget build(BuildContext context) &#123;
    return Scaffold(
      appBar: _buildAppBar(),
      body: _buildBody(),
      floatingActionButton: _buildFloatingButton(),
    );
  &#125;

  PreferredSizeWidget _buildAppBar() &#123;
    return AppBar(title: Text(&#39;List View Demo&#39;));
  &#125;

  /// todo - 打开注释就可以成功切换颜色额
  Widget _buildBody() &#123;
    return ListView(
      itemExtent: 66,
      children: [
        ListCell(
          color: colors[0],
          // key: UniqueKey(),
        ),
        ListCell(
          color: colors[1],
          // key: UniqueKey(),
        ),
      ],
    );
  &#125;

  Widget _buildFloatingButton() &#123;
    return FloatingActionButton(
      onPressed: () &#123;
        setState(() &#123;
          final color = colors.removeLast();
          colors.insert(0, color);
          setState(() &#123;&#125;);
        &#125;);
      &#125;,
      child: Icon(Icons.add),
    );
  &#125;
&#125;

class ListCell extends StatefulWidget &#123;
  const ListCell(&#123;
    required this.color,
    Key? key,
  &#125;) : super(key: key);

  final Color color;

  @override
  _ListCellState createState() &#123;
    return _ListCellState(color);
  &#125;
&#125;

class _ListCellState extends State&lt;ListCell&gt; &#123;
  _ListCellState(this.color);
  Color color;

  @override
  Widget build(BuildContext context) &#123;
    return Container(
      margin: EdgeInsets.fromLTRB(8.0, 8.0, 8.0, 8.0),
      color: color,
    );
  &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>flutter使用外部字体</title>
    <url>/2021/10/21/flutter%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<p>flutter 使用外部字体有两种方式</p>
<ol>
<li>直接导入到项目中去</li>
<li>使用带有该字体的 packages 包导入<br>但是不论是哪一种，都得在 pubspec.yaml 文件中进行相应的配置，例如<br><img src="/2021/10/21/flutter%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%AD%97%E4%BD%93/1.jpg"></li>
</ol>
<p> <br>其中 DIN 字体是由外部库导入的，Festive 则是通过项目导入的。（注意：”DIN” 和 “Festive” 只是一个标识符，它与字体的名字可以不一致。）</p>
<p>其中有几个字段需要说明一下</p>
<h4 id="family"><a href="#family" class="headerlink" title="family"></a><strong>family</strong></h4><p>决定了字体的名字，它用于 TextStyle 对象的 fontFamily 属性</p>
<h4 id="asset"><a href="#asset" class="headerlink" title="asset"></a><strong>asset</strong></h4><p>指定了字体文件的路径，这个路径是相对于 pubspec.yaml 文件的。（注意，这里的字体文件只能在 App 编译的时候，存放到 bundle 中，所以不支持热重载）</p>
<p>每个单独的字体可以使用不同字重的字体文件，而且还可以制定 weight 和 style 参数</p>
<h4 id="weight"><a href="#weight" class="headerlink" title="weight"></a><strong>weight</strong></h4><p>用来说明字体文件的字重，它是 100 的整数倍，范围是 100-900</p>
<h4 id="style"><a href="#style" class="headerlink" title="style"></a><strong>style</strong></h4><p>用来说明字体文件的样式，值为 normal 和 italic</p>
<p>注意：<br>他们仅作为说明用，并不能影响到实际效果，例如，对粗体样式的字体文件指定一个 weight &#x3D; 100，它是不起作用的，同样的，对斜体（italic）样式的字体文件指定 style &#x3D; normal，也是不起作用的。</p>
<p>不过，在上图中，可以看到 Festive 这个字体有两个字体文件，分别为 Regular 和 Bold 样式，他们是不同的字体！！这样会有一个什么样的效果呢<br><img src="/2021/10/21/flutter%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%AD%97%E4%BD%93/2.jpg"><br><img src="/2021/10/21/flutter%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%AD%97%E4%BD%93/3.jpg"><br>（第一行为 Festive，第二行为 DIN-Bold）<br>由此可见 flutter 并不会校验他们是否为同一个字体。它只会在你使用这个 family 的字体时，根据你传入的 fontWeight 来选择不同的字体文件进行文案展示，这是需要注意的地方。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter列表放大效果</title>
    <url>/2021/10/26/flutter%E5%88%97%E8%A1%A8%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>在 flutter 中，如果我们需要做一个类似如下效果的控件<br><img src="/2021/10/26/flutter%E5%88%97%E8%A1%A8%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C/1.gif">
 </p>
<p>第一个想到的就是 PageView，但是 PageView 在我们的认识中，只能实现类似于 Banner 广告那样，按照整页切换的效果.</p>
<p>其实只需要设置 PageController 的 viewportFraction 这个参数即可，这个参数标志者每一“页”的屏幕占比是多少，例如 Banner 广告是整页切换的，那么 viewportFraction &#x3D; 1.0，上图中的控件 viewportFraction &#x3D; 1 &#x2F; 5.0.</p>
<p>具体实现可以参考官方教程</p>
<p><a href="https://flutter.cn/docs/cookbook/effects/photo-filter-carousel">https://flutter.cn/docs/cookbook/effects/photo-filter-carousel</a></p>
<p>那么问题又来了，假如我还想让中间的控件放大到三个控件的大小，也就是按照“小-大-小”这样来排列，该如何做？</p>
<p>这个时候就需要将 Scrollable 和 Flow 搭配使用了，其中还需要自己实现一个 FlowDelegate 类。目前实现了一个简单 Demo<br><img src="/2021/10/26/flutter%E5%88%97%E8%A1%A8%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C/2.gif"><br>￼</p>
]]></content>
  </entry>
  <entry>
    <title>flutter多语言问题</title>
    <url>/2021/10/09/flutter%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>flutter 多语言爆出 intl_utils 找不到 pubspec.yaml 文件时的解决办法<br>命令行执行 flutter pub global deactivate intl_utils 后，修改一下多语言文件，保存触发脚本自动执行后即可修复</p>
]]></content>
  </entry>
  <entry>
    <title>flutter屏幕刷新结束回调</title>
    <url>/2021/09/02/flutter%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E7%BB%93%E6%9D%9F%E5%9B%9E%E8%B0%83/</url>
    <content><![CDATA[<p>三种屏幕刷新结束（动画帧完成回调）的方式，他们分别是</p>
<ul>
<li>AnimationController.addListener</li>
<li>Ticker</li>
<li>WidgetsBinding.instance.addPostFrameCallback</li>
</ul>
<ol>
<li><p>其中 AnimationController 的方式我们用的最多，所以不在多说</p>
</li>
<li><p>Ticker 大家接触的比较少，因为 AnimationController 帮我们处理了，在使用 AnimationController 的时候，需要混入 SingleTickerProviderStateMixin 或者 TickerProviderStateMixin，它赋予了 State 对象创建 Ticker 的能力，通过 mixin 中的 createTicker api，可以创建一个 Ticker 对象，每一个动画帧完成绘制时，都会产生一个回调告诉我们</p>
</li>
<li><p>WidgetsBinding.instance.addPostFrameCallback 也是经常用到的一个，使用场景一般都是和 RenderObject 相关的，因为在我们调用 setState 的时候，当前动画帧可能还没有更新，所以导致使用 RenderObject 获取的 Widget 相关信息有误，通过该方法，在回调中获取 RenderObject 的信息时，就是正确的了。（常用在获取某个 Widget 在屏幕中的位置）</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>flutter的ScrollView相关的滑动通知</title>
    <url>/2021/08/09/flutter%E7%9A%84ScrollView%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BB%91%E5%8A%A8%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<h3 id="今天研究了下-ScrollView-相关的通知，一共有五个"><a href="#今天研究了下-ScrollView-相关的通知，一共有五个" class="headerlink" title="今天研究了下 ScrollView 相关的通知，一共有五个"></a>今天研究了下 ScrollView 相关的通知，一共有五个</h3><ul>
<li>ScrollStartNotification</li>
<li>ScrollUpdateNotification</li>
<li>ScrollEndNotification</li>
<li>UserScrollNotification</li>
<li>OverscrollNotification</li>
</ul>
<h3 id="从名字上可以看出来"><a href="#从名字上可以看出来" class="headerlink" title="从名字上可以看出来"></a>从名字上可以看出来</h3><p><strong>ScrollStartNotification</strong> - 滚动开始通知</p>
<p><strong>ScrollUpdateNotification</strong> - 滚动更新通知</p>
<p><strong>ScrollEndNotification</strong> - 滚动结束三个通知。</p>
<p><strong>UserScrollNotification</strong> - 在打印通知的时候，大家可能会有点疑惑，因为分别在滚动开始和滚动结束的时候各打印了一次，但是我（用户）只滑动了一次，有点奇怪。<br>其实，这个通知是在 ScrollView 滚动法相发生改变的时候发出的。在我们滑动时，滚动方向由 ScrollDirection.idle 变成了 ScrollDirection.forward，发送一次该通知；等到滚动慢慢停止后，滚动方向由 ScrollDirection.forward 变成了 ScrollDirection.idle，又发送了一次，所以会有两次。</p>
<p><strong>OverscrollNotification</strong> - 顾名思义，超出了滚动范围才发出该通知，但是要注意的是，如果 ScrollPhysics 带有弹簧效果的，那么不会发出该通知，只有将其设置为 ClampingScrollPhysics 后，接着滑动到边缘继续滑动，才会发出该通知。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter防抖与节流</title>
    <url>/2022/05/26/flutter%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>防抖（debounce），节流，可重入与不可重入</p>
<p>在开发工作中，我们根据某些回调来执行某些操作。有的回调触发得十分频繁（例如滚动事件监听，鼠标位置监听，输入监听等）。导致回调处理会频繁得被触发，如果其中包含了网络请求或者文件读写，就会造成比较大的开销。</p>
<p>所以我们不希望它执行的太过频繁，我们希望降低执行它的频率，或者在执行结束前，不允许再次执行回调内容。这就涉及到了防抖节流与可重入不可重入。</p>
<h3 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h3><p>设定一个时间间隔，每次调用后，等待该时间间隔然后执行，如果在等待过程中又有调用，则重新计时，上代码</p>
<pre><code class="dart">/// 函数防抖
///
/// [func]: 要执行的方法
/// [delay]: 要迟延的时长
void Function() debounce(
  Function func, [
  Duration delay = const Duration(milliseconds: 500),
]) &#123;
  Timer? timer;
  void Function() target = () &#123;
    timer?.cancel();
    timer = Timer(delay, () &#123;
      func.call();
    &#125;);
  &#125;;
  return target;
&#125;
</code></pre>
<p>这里使用了一个函数，接受一个函数对象作为参数并返回一个新的函数对象，每次调用 debounce 时，会刷新定时器，然后延时 500ms 后调用传入的函数对象。</p>
<h3 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h3><p>设定一个时间间隔，每次调用时，开启一个定时器并立刻执行，在此定时器倒计时结束前的所有调用都会被忽略。上代码</p>
<pre><code class="dart">/// 节流
///
/// [func]: 要执行的方法
/// [delay]: 要迟延的时长
Function throttle(
  Function func, [
  Duration delay = const Duration(milliseconds: 500),
]) &#123;
  Timer? timer;
  return () &#123;
    if (timer != null) return;
    timer = Timer(delay, () &#123;
      func.call();
    &#125;);
  &#125;;
&#125;
</code></pre>
<p>仍然是接受一个函数对象作为参数并返回一个新的函数对象，每次调用 throttle 时，会先检查定时器是否已经开启，如果未开启，则调用函数并开启定时器，否则直接返回。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter隐式动画</title>
    <url>/2021/10/19/flutter%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>flutter 本身提供了一系列的隐式动画控件，一些简单的效果再也不需要自己写 AnimationController 了<br>透明度动画</p>
<pre><code class="dart">AnimatedOpacity(
  duration: Duration(milliseconds: 500),
  opacity: _visible ? 1.0 : 0.0,
  child: Container(
    width: 200.0,
    height: 200.0,
    color: Colors.green,
  ),
)
</code></pre>
<p>背景颜色、宽度高度、圆角动画</p>
<pre><code class="dart">AnimatedContainer(
  duration: Duration(milliseconds: 300),
  width: _width,
  height: _height,
  decoration: BoxDecoration(
    color: _color,
    borderRadius: BorderRadius.circular(_radius),
  ),
)
</code></pre>
<p>只需要传入 duration 即可实现隐式动画，不需要写额外的代码，非常方便。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter项目只能通过Xcode运行的问题</title>
    <url>/2021/07/07/flutter%E9%A1%B9%E7%9B%AE%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87Xcode%E8%BF%90%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>找到了导致使用 Xcode 可以运行，但是使用 Flutter 无法运行 App 的原因之一。</p>
<p><strong>先说结论</strong></p>
<p>project.pbxproj 文件中的 ARCH 参数会影响使用 Flutter 运行 App，但是不会影响使用 Xcode 运行 App，所以删除所有的 ARCH 与 EXCLUDED_ARCHS 字段。</p>
<p><strong>发现过程</strong><br>原因就在于对于 BuildSettings 中的某些操作，即使你没有修改任何值，由于 Xcode 自身的原因，也会修改掉某些配置内容，而且这个还是无法还原。例子如下：</p>
<ol>
<li>打开终端，进入某个目录中</li>
<li>依次执行</li>
</ol>
<pre><code class="bash">flutter create test_app（创建一个新的 app）
cd test_app（进入 App 目录）
git init（创建版本控制，方便观察变更）
git add .
git commit -m &#39;InitialCommit&#39;（创建初始提交）
flutter run（开始运行）
</code></pre>
<p>发现 App 能够正常运行</p>
<ol start="3">
<li><p>接着我们打开 test_app&#x2F;ios&#x2F;Runner.xcworkspace 工程，进入 Runner 的 BuildSetting 中，内容如图所示（可能有所区别，但是不影响）<br><img src="/2021/07/07/flutter%E9%A1%B9%E7%9B%AE%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87Xcode%E8%BF%90%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/1.png"></p>
</li>
<li><p>接着双击 Excluded Archtecture - Debug<br><img src="/2021/07/07/flutter%E9%A1%B9%E7%9B%AE%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87Xcode%E8%BF%90%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/2.png"></p>
</li>
<li><p>什么都不做，直接点击空白处取消，你会发现原来的 arm64 与 i386 不见了，但是双击 Any iOS Simulator SDK 时，仍然可以看到<br><img src="/2021/07/07/flutter%E9%A1%B9%E7%9B%AE%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87Xcode%E8%BF%90%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/3.jpg"></p>
</li>
</ol>
<p>但是这个时候，你再执行 flutter run ，你会发现，已经没有办法在模拟器中跑起来了<br><img src="/2021/07/07/flutter%E9%A1%B9%E7%9B%AE%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87Xcode%E8%BF%90%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/4.png"></p>
<p>观察文件变更后发现，这个操作添加了一个新的配置字段，覆盖掉了默认值，最后导致无法使用 Flutter 运行。<br><img src="/2021/07/07/flutter%E9%A1%B9%E7%9B%AE%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87Xcode%E8%BF%90%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/5.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>flutter项目无法真机运行的解决方法</title>
    <url>/2021/11/17/flutter%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E7%9C%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天着手解决了 iOS 真机无法运行右糖的问题，遇到了不少坑，记录一下</p>
<h3 id="一、编译运行没问题，但是卡在了启动页"><a href="#一、编译运行没问题，但是卡在了启动页" class="headerlink" title="一、编译运行没问题，但是卡在了启动页"></a>一、编译运行没问题，但是卡在了启动页</h3><p>观察控制台发现了相关信息</p>
<p>Failed to register observatory port with mDNS with error -65555.</p>
<p>On iOS 14+, local network broadcast in apps need to be declared in the app’s Info.plist. Debug and profile Flutter apps and modules host VM services on the local network to support debugging features such as hot reload and DevTools. To make your Flutter app or module attachable and debuggable, add a ‘_dartobservatory._tcp’ value to the ‘NSBonjourServices’ key in your Info.plist for the Debug&#x2F;Profile configurations. For more information, see <a href="https://flutter.dev/docs/development/add-to-app/ios/project-setup#local-network-privacy-permissions">https://flutter.dev/docs/development/add-to-app/ios/project-setup#local-network-privacy-permissions</a></p>
<p>这个问题好解决，通过给出的地址，按照官方教的步骤进行即可，简单来说就是向 Info.plist 文件中需要加两个字段。</p>
<h3 id="二、这个问题就比较棘手了"><a href="#二、这个问题就比较棘手了" class="headerlink" title="二、这个问题就比较棘手了"></a>二、这个问题就比较棘手了</h3><p>经过第一步修改，没有报上述错误了，但是仍然卡在启动页无法进入首页，观察后发现应该是 flutter 没有启动成功，这一次的错误很好找<br><img src="/2021/11/17/flutter%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E7%9C%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/1.jpg"></p>
<p><strong>Dart Error: Can’t load Kernel binary: Invalid kernel binary version.</strong></p>
<p>一个和内核相关的问题，上 github 查了下，发现将原来的 flutter 替换成官网下载的新的 flutter ，然后进行编译即可，应该是先前的某些操作导致真机部分的内核失效了。</p>
]]></content>
  </entry>
  <entry>
    <title>flutter骨架动画</title>
    <url>/2021/11/02/flutter%E9%AA%A8%E6%9E%B6%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>loading 对于右糖来说是没法避免的，只能通过各种方式来规避，先前说过，在某些页面可以使用骨架图来代替 loading 转圈圈，感觉更容易让人接受，正好今天尝试了一下，以右糖为例，先看效果。<br><img src="/2021/11/02/flutter%E9%AA%A8%E6%9E%B6%E5%8A%A8%E7%94%BB/1.mp4"></p>
<p>效果的核心类是 ShaderMask。做法其实很简单。</p>
<ol>
<li>绘制出纯色的骨架控件，图片，文字等用纯色矩形代替，</li>
<li>接着根据你想要显示出来的骨架样式，创建对应的 Shader，右糖这里使用了渐变色的效果，所以使用 LinearGradient().createShader。</li>
<li>为了是骨架样式动起来，你还需要一个动画控制器来控制动画，createShader 可以传入一个 Rect 参数来计算该显示 Gradient 的某一部分，通过修改这一部分的位置，达到闪烁的动画效果。</li>
</ol>
<p>使用方法如下，只需传入你所需要的骨架控件即可。<br><img src="/2021/11/02/flutter%E9%AA%A8%E6%9E%B6%E5%8A%A8%E7%94%BB/2.jpg"></p>
<p>核心代码如下</p>
<pre><code class="dart">// @dart = 2.13
import &#39;package:flutter/material.dart&#39;;

const _shimmerGradient = LinearGradient(
  colors: [
    Color(0xFFEBEBF4),
    Color(0xFFF4F4F4),
    Color(0xFFEBEBF4),
  ],
  stops: [
    0.1,
    0.3,
    0.4,
  ],
  begin: Alignment(-1.0, -0.3),
  end: Alignment(1.0, 0.3),
  tileMode: TileMode.clamp,
);

class ShimmerLoading extends StatefulWidget &#123;
  const ShimmerLoading(&#123;
    Key? key,
    required this.isLoading,
    required this.child,
  &#125;) : super(key: key);

  final bool isLoading;
  final Widget child;

  @override
  _ShimmerLoadingState createState() =&gt; _ShimmerLoadingState();
&#125;

class _ShimmerLoadingState extends State&lt;ShimmerLoading&gt; &#123;
  Listenable? _shimmerChanges;

  @override
  void didChangeDependencies() &#123;
    super.didChangeDependencies();
    if (_shimmerChanges != null) &#123;
      _shimmerChanges!.removeListener(_onShimmerChange);
    &#125;
    _shimmerChanges = Shimmer.of(context)?.shimmerChanges;
    if (_shimmerChanges != null) &#123;
      _shimmerChanges!.addListener(_onShimmerChange);
    &#125;
  &#125;

  @override
  void dispose() &#123;
    _shimmerChanges?.removeListener(_onShimmerChange);
    super.dispose();
  &#125;

  @override
  Widget build(BuildContext context) &#123;
    if (widget.isLoading == false) &#123;
      return widget.child;
    &#125;

    final shimmer = Shimmer.of(context)!;
    if (shimmer.isSized == false) &#123;
      return SizedBox();
    &#125;

    final shimmerSize = shimmer.size;
    final gradient = shimmer.gradient;
    final offsetWithinShimmer = shimmer.getDescendantOffset(
      descendant: context.findRenderObject() as RenderBox,
    );

    return ShaderMask(
      blendMode: BlendMode.srcATop,
      shaderCallback: (bounds) &#123;
        return gradient.createShader(Rect.fromLTWH(
          -offsetWithinShimmer.dx,
          -offsetWithinShimmer.dy,
          shimmerSize.width,
          shimmerSize.height,
        ));
      &#125;,
      child: widget.child,
    );
  &#125;

  void _onShimmerChange() &#123;
    if (widget.isLoading) &#123;
      setState(() &#123;&#125;);
    &#125;
  &#125;
&#125;

class Shimmer extends StatefulWidget &#123;
  static ShimmerState? of(BuildContext context) &#123;
    return context.findAncestorStateOfType&lt;ShimmerState&gt;();
  &#125;

  const Shimmer(&#123;
    Key? key,
    this.child,
  &#125;) : super(key: key);

  final Widget? child;

  @override
  ShimmerState createState() =&gt; ShimmerState();
&#125;

class ShimmerState extends State&lt;Shimmer&gt; with SingleTickerProviderStateMixin &#123;
  late AnimationController _shimmerController;

  Gradient get gradient =&gt; LinearGradient(
        colors: _shimmerGradient.colors,
        stops: _shimmerGradient.stops,
        begin: _shimmerGradient.begin,
        end: _shimmerGradient.end,
        transform: _SlidingGradientTransform(slidePercent: _shimmerController.value),
      );

  Listenable get shimmerChanges =&gt; _shimmerController;

  bool get isSized &#123;
    final obj = context.findRenderObject();
    if (obj == null) return false;
    final box = obj as RenderBox;
    return box.hasSize;
  &#125;

  Size get size =&gt; (context.findRenderObject() as RenderBox).size;

  Offset getDescendantOffset(&#123;
    required RenderBox descendant,
    Offset offset = Offset.zero,
  &#125;) &#123;
    final shimmerBox = context.findRenderObject() as RenderBox;
    return descendant.localToGlobal(offset, ancestor: shimmerBox);
  &#125;

  @override
  void initState() &#123;
    super.initState();
    _shimmerController = AnimationController.unbounded(vsync: this)
      ..repeat(
        min: -0.5,
        max: 1.5,
        period: Duration(milliseconds: 1000),
      );
  &#125;

  @override
  void dispose() &#123;
    _shimmerController.dispose();
    super.dispose();
  &#125;

  @override
  Widget build(BuildContext context) &#123;
    return widget.child ?? SizedBox();
  &#125;
&#125;

class _SlidingGradientTransform extends GradientTransform &#123;
  const _SlidingGradientTransform(&#123;
    required this.slidePercent,
  &#125;);

  final double slidePercent;

  @override
  Matrix4? transform(Rect bounds, &#123;TextDirection? textDirection&#125;) &#123;
    return Matrix4.translationValues(bounds.width * slidePercent, 0.0, 0.0);
  &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>iOS App Instrument 超浅谈</title>
    <url>/2021/11/08/iOS-App-Instrument-%E8%B6%85%E6%B5%85%E8%B0%88/</url>
    <content><![CDATA[<p>今天看了下苹果提供的一篇关于提供 App 性能的文章，又有了新的一些想法。<br><a href="https://developer.apple.com/documentation/metrickit/improving_your_app_s_performance">https://developer.apple.com/documentation/metrickit/improving_your_app_s_performance</a></p>
<p>在我们发布版本之前，测试会有一轮完整的功能性测试，其实，不仅仅是这一轮，目前我们右糖全部都是黑盒测试，将 App 视为一个内部不明的盒子，测试的一个给定的输入与预期的输出是否一致。</p>
<p>但是对于 App 内部的一些东西，他们很难发现，或者说完全不能发现。</p>
<p>但是我们可以通过 Xcode 提供的一系列工具，可以很好的对这些看不见的性能指标进行监测，不论是流量使用，磁盘 IO，电量用量等，均可以获取到相应的数据。形成相应的报告。</p>
<p>例如 Xcode 提供的整合工具 Instrument<br><img src="/2021/11/08/iOS-App-Instrument-%E8%B6%85%E6%B5%85%E8%B0%88/1.jpg"></p>
<p>相较于原生开发，flutter 监测起来会更麻烦一些，但是这无疑给我们又提供了一个新的方法。</p>
<p>而且，不仅仅有 Instrument，文档中还提到了一个 MetricKit 库，它允许我们自定义数据报告，类似于 Apple 自己的一个埋点服务，下面是视频链接（中文），有兴趣的可以看看</p>
<p><a href="https://developer.apple.com/videos/play/wwdc2020/10081">https://developer.apple.com/videos/play/wwdc2020/10081</a></p>
<p>总结了一下，使用 Instrument 调试 App，以获取性能指标，这个得在本地实现。通过 MetricKit 获取真实用户使用过程中的性能指标，这个在 Xcode Organizer 中查看。</p>
]]></content>
  </entry>
  <entry>
    <title>iOS开发小技巧</title>
    <url>/2015/11/30/iOS%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="计算文字尺寸"><a href="#计算文字尺寸" class="headerlink" title="计算文字尺寸"></a>计算文字尺寸</h2><pre><code class="swift">let text = &quot;123&quot;
let size = (text as NSString).boundingRect(with: .zero, attributes: [.font: UIFont.systemFont(ofSize: 20.0)], context: nil)
</code></pre>
<h2 id="胶囊体判断"><a href="#胶囊体判断" class="headerlink" title="胶囊体判断"></a>胶囊体判断</h2><pre><code class="c++">int capsule(float px, float py, float ax, float ay, float bx, float by, float r) &#123;
    float pax = px - ax;
    float pay = py - ay;
    float bax = bx - ax;
    float bay = by - ay;
    float h = max(min((pax * bax + pay * bay) / (bax * bax + bay * bay), 1.0f), 0.0f);
    float dx = pax - bax * h, dy = pay - bay * h;
    return dx * dx + dy * dy &lt; r * r;
&#125;
</code></pre>
<h2 id="NSTextView计算当前文本内容大小"><a href="#NSTextView计算当前文本内容大小" class="headerlink" title="NSTextView计算当前文本内容大小"></a>NSTextView计算当前文本内容大小</h2><pre><code class="swift">let rect: CGRect = textView.layoutManager.usedRect(for: textView.textContainer)
</code></pre>
<h2 id="生成纯色图片"><a href="#生成纯色图片" class="headerlink" title="生成纯色图片"></a>生成纯色图片</h2><pre><code class="swift">extension UIImage &#123;
    static func get_image(color: UIColor) -&gt; UIImage? &#123;
        let rect = CGRect(x: 0, y: 0, width: 1, height: 1)
        UIGraphicsBeginImageContext(rect.size)
        let context = UIGraphicsGetCurrentContext()
        context?.setFillColor(color.cgColor)
        context?.fill(rect)
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return image
    &#125;
&#125;
</code></pre>
<h2 id="使用-CGAffineTransform-缩放后文字不变模糊"><a href="#使用-CGAffineTransform-缩放后文字不变模糊" class="headerlink" title="使用 CGAffineTransform 缩放后文字不变模糊"></a>使用 CGAffineTransform 缩放后文字不变模糊</h2><pre><code class="swift">public class ScaleLabel: UILabel &#123;
    public override class var layerClass: AnyClass &#123;
        return CATiledLayer.classForCoder()
    &#125;
    
    public override init(frame: CGRect) &#123;
        super.init(frame: frame)
        if let _layer = self.layer as? CATiledLayer &#123;
            _layer.levelsOfDetail = 10
            _layer.levelsOfDetailBias = 10
        &#125;
    &#125;
    
    required init?(coder: NSCoder) &#123;
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    &#125;
&#125;
</code></pre>
<h2 id="present-一个带透明度背景的-VC"><a href="#present-一个带透明度背景的-VC" class="headerlink" title="present 一个带透明度背景的 VC"></a>present 一个带透明度背景的 VC</h2><pre><code class="swift">let vc2 = SignInResultVC() 
vc2.definesPresentationContext = true 
vc2.modalPresentationStyle = .overCurrentContext 
self.present(vc2, animated: true, completion: nil)
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>iPhone屏幕尺寸与状态栏高度速查表</title>
    <url>/2022/01/25/iPhone%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E4%B8%8E%E7%8A%B6%E6%80%81%E6%A0%8F%E9%AB%98%E5%BA%A6%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">屏幕尺寸</th>
<th align="center">状态栏高度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">375x667</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">414x736</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">414x896</td>
<td align="center">44</td>
</tr>
<tr>
<td align="center">390x844</td>
<td align="center">47</td>
</tr>
<tr>
<td align="center">428x926</td>
<td align="center">47</td>
</tr>
<tr>
<td align="center">375x812</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">320x568</td>
<td align="center">20</td>
</tr>
</tbody></table>
<p>发现全面屏 iPhone 的状态栏高度居然是不相同的</p>
<p>假如隐藏了状态栏，通过 UIApplication.shared.statusBarFrame.height api 获取到的状态栏高度为 0，这在开发中需要注意一下</p>
]]></content>
  </entry>
  <entry>
    <title>macOS OpenCV 环境配置</title>
    <url>/2022/06/02/macOS-OpenCV-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>macOS OpenCV 环境配置</p>
<ol>
<li><p>安装 homebrew（<a href="https://brew.sh)/">https://brew.sh）</a></p>
</li>
<li><p>使用 brew install opencv 安装 opencv</p>
</li>
<li><p>使用 brew info opencv 查看库文件路径<br><img src="/2022/06/02/macOS-OpenCV-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.jpg"></p>
</li>
<li><p>创建 macOS 工程，使用 Swift、OC、C++ 混编</p>
</li>
<li><p>在 build setting 中找到 Header Search Paths，输入 opencv 头文件路径<br><img src="/2022/06/02/macOS-OpenCV-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.jpg"></p>
</li>
<li><p>根据需要，导入相应的二进制文件，我使用了视频处理 + 图片处理，所以使用了如下 4 个库<br><img src="/2022/06/02/macOS-OpenCV-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.jpg"></p>
</li>
</ol>
<p>至此，OpenCV 已经部署完毕，可以进行开发了，注意，需要使用 Swift 调 OC 调 C++ 的方法来使用 OpenCV </p>
]]></content>
  </entry>
  <entry>
    <title>inputAccessoryView 中需要 UITextField 时的处理方式</title>
    <url>/2019/06/06/inputAccessoryView-%E4%B8%AD%E9%9C%80%E8%A6%81-UITextField-%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我有一个 UITextField 控件，在激活时，需要在弹出键盘的上方加一个 UITextField 和确认按钮，供用户输入与确认。</p>
<h2 id="初始方案"><a href="#初始方案" class="headerlink" title="初始方案"></a>初始方案</h2><p>实现原 UITextField 代理方法 func textFieldDidBeginEditing(_ textField: UITextField)</p>
<p>将 inputAccessoryView 中的 UITextField 设为第一响应者</p>
<pre><code class="swift">class ViewController: UIViewController &#123;
    let text_field = UITextField()
    let intpu_view = UITextField()
    text_field.inputAccessoryView = input_view
&#125;
</code></pre>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>监听键盘弹出事件，等键盘弹出后，将 inputAccessoryView 中的 UITextField 设为第一响应者</p>
<h2 id="方案三（建议）"><a href="#方案三（建议）" class="headerlink" title="方案三（建议）"></a>方案三（建议）</h2><p>伪装 inputAccessoryView，将原 UITextField 改为 UILabel，点击时将 inputAccessoryView 中的 UITextField 设为第一响应者，通过监听键盘弹出与收起通知，获取动画与键盘frame信息，使用动画将 UITextField 置于键盘上方，伪装成 inputAccessoryView。</p>
<p>注意如果不将 inputAccessoryView 通过 addSubview 添加到屏幕上，则它无法成为第一响应者，无法弹出键盘</p>
]]></content>
  </entry>
  <entry>
    <title>macOS 小技巧</title>
    <url>/2019/07/07/macOS-%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="curl-参数"><a href="#curl-参数" class="headerlink" title="curl 参数"></a>curl 参数</h2><p>-i 显示 response 头部信息</br><br>-I 仅显示 response 头部信息</br><br>-H 增加 request header</br></p>
<p>显示 response 头部</br></p>
<pre><code>➜  ~ curl -I localhost
HTTP/1.1 200 OK
Server: nginx/1.23.3
Date: Tue, 03 Jan 2023 08:51:48 GMT
Content-Type: text/html
Content-Length: 615
Last-Modified: Tue, 13 Dec 2022 15:53:57 GMT
Connection: keep-alive
ETag: &quot;6398a015-267&quot;
Accept-Ranges: bytes
</code></pre>
<h2 id="Provisioning-Profile-文件地址"><a href="#Provisioning-Profile-文件地址" class="headerlink" title="Provisioning Profile 文件地址"></a>Provisioning Profile 文件地址</h2><p>~&#x2F;Library&#x2F;MobileDevice&#x2F;Provisioning Profiles&#x2F;</p>
]]></content>
  </entry>
  <entry>
    <title>人像自动居中</title>
    <url>/2022/11/25/%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>通过 CIDetector 检测图片中存在的人像，通过获取到眼睛与鼻子的相对位置，眼距，眼睛的夹角，以及眼睛与嘴巴形成的三角形的重心，有了这些信息就可以通过计算，得到对应的 transform 将照片中的人像移动到屏幕的中心位置</p>
<p>效果如下<br><img src="/2022/11/25/%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E5%B1%85%E4%B8%AD/1.jpg"><br><img src="/2022/11/25/%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E5%B1%85%E4%B8%AD/2.jpg"><br><img src="/2022/11/25/%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E5%B1%85%E4%B8%AD/3.jpg"><br><img src="/2022/11/25/%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E5%B1%85%E4%B8%AD/4.jpg"></p>
<p>代码如下<br><img src="/2022/11/25/%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E5%B1%85%E4%B8%AD/1.swift" alt="代码"></p>
]]></content>
  </entry>
  <entry>
    <title>上传优化&amp;任务加载优化</title>
    <url>/2022/02/22/%E4%B8%8A%E4%BC%A0%E4%BC%98%E5%8C%96-%E4%BB%BB%E5%8A%A1%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>对于上传及加载本身，移动端这边可以做的并不是很多，主要的策略还是空间换时间，这个和谷歌的 Chrome 浏览器有点相似，后者是用内存换取性能上的优势。</p>
<p>所以，目前这两点优化的核心就是做缓存，以及如何高效地利用缓存。我们都是贪婪的，既想着，我需要的东西，缓存任何时候都能准确提供；又想要缓存中的内容一旦失效，可以立刻被清除出去，不占用多余的空间，但显然这个是不容易做到的。</p>
<p>在开始做缓存功能之前，我们先要解决几个问题：</p>
<p>首先，我们需要缓存等待上传的文件</p>
<p>第二个问题则有点棘手，VIP 用户最多可以上传 100 张素材，假如其中有几个视频，那一个任务中的素材，可能会达到好几个 G，多来几个这样的任务，十个 G 就没了，所以接下来的两个问题很重要</p>
<ol>
<li>什么时候缓存</li>
<li>什么时候清除缓存</li>
<li>第一个很好回答，用户点击保存或者制作的时候进行缓存就可以，下次用户进入这个任务时，可以直接读取缓存中的文件进行展示。</li>
</ol>
<p>第二个问题稍微有点复杂，正常流程下，任务的素材上传成功后就可以清除了，但同时也需要考虑失败或者别的情况，例如用户删除了任务，用户取消上传后又重新对任务进行了编辑的情况。</p>
<p>本次迭代主要是方案的确定，这样可以留出更多的时间让我们完善这个方案，尽可能的考虑多种情况，以及各个情况下的处理方式，这样写出来的程序就比较健壮，不容易出错。</p>
]]></content>
  </entry>
  <entry>
    <title>使用 Mask 时允许部分被遮住的 View 的交互事件</title>
    <url>/2023/02/01/%E4%BD%BF%E7%94%A8-Mask-%E6%97%B6%E5%85%81%E8%AE%B8%E9%83%A8%E5%88%86%E8%A2%AB%E9%81%AE%E4%BD%8F%E7%9A%84-View-%E7%9A%84%E4%BA%A4%E4%BA%92%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<pre><code class="swift">class Mask: UIView &#123;
    weak var view: UIView?
    
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123;
        if let view = view &#123;
            let view_point = view.convert(point, from: self)
            if view.point(inside: view_point, with: event) &#123;
                return view
            &#125;
        &#125;
        return super.hitTest(point, with: event)
    &#125;
&#125;
</code></pre>
<p>上段代码只会筛选当前 view，不会相应其 subview 的事件，如果需要也相应 subview 的交互，使用如下代码</p>
<pre><code class="swift">override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123;
    if let sticker = sticker &#123;
        for i in stride(from: sticker.subviews.count - 1, to: 0, by: -1) &#123;
            let view = sticker.subviews[i]
            let view_point = view.convert(point, from: self)
            if view.point(inside: view_point, with: event) &#123;
                return view
            &#125;
        &#125;
    &#125;
    return super.hitTest(point, with: event)
&#125;
</code></pre>
<p>完整代码如下</p>
<pre><code class="swift">class Mask: UIView &#123;
    
    weak var view: View?
            
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123;
        if let view = view &#123;
            for i in stride(from: view.subviews.count - 1, to: 0, by: -1) &#123;
                let view = view.subviews[i]
                let view_point = view.convert(point, from: self)
                if view.point(inside: view_point, with: event) &#123;
                    return view
                &#125;
            &#125;
        &#125;
        return super.hitTest(point, with: event)
    &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>使用 Metal 渲染显示图片时图片变斜的问题</title>
    <url>/2022/11/04/%E4%BD%BF%E7%94%A8-Metal-%E6%B8%B2%E6%9F%93%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E6%97%B6%E5%9B%BE%E7%89%87%E5%8F%98%E6%96%9C%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>通过 UIGraphicsGetImageFromCurrentImage Context方法 resize 后的图片，它的 bittmap 会进行对齐操作，例如一张 1x1 的 rgba 图片，bitmap 数据的长度应该是 4 个字节，但是使用该方法 resize 到 1x1 进行处理之后，系统会自动堆内存进行对齐操作，bitmap 长度就由 1 个字节变成了 32 个字节，就会导致 cgimage.bytesPerRow * height 与 bitmap data 的长度不相等</p>
<p>在使用MTLTexture保存并显示纹理的时候，如果不对这一块进行处理，就会产生图片变斜了的问题，原因就是对这些由于“对齐”而产生的多余数据进行了解析。</p>
]]></content>
  </entry>
  <entry>
    <title>使用 copy 与 mutableCopy 时可能会遇到的坑</title>
    <url>/2017/06/03/%E4%BD%BF%E7%94%A8-copy-%E4%B8%8E-mutableCopy-%E6%97%B6%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>对内存地址的复制，让目标对象指针和源对象指向同一片内存空间.</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/2017/06/03/%E4%BD%BF%E7%94%A8-copy-%E4%B8%8E-mutableCopy-%E6%97%B6%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/1.png"><br>由于 copy 方法返回的是 immutable 对象，是不可变的，所以对 b 调用 appendString 方法就会报错<br>将 copy 改为 mutableCopy 即可修复该问题</p>
]]></content>
  </entry>
  <entry>
    <title>使用代码初始化 App</title>
    <url>/2016/11/12/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B%E5%8C%96-App/</url>
    <content><![CDATA[<p>使用代码初始化App<br>打开 AppDelegate.m，如果没有 window 属性，则手动添加一个，并在 didFinishLaunch 方法中加入如下代码</p>
<pre><code class="swift">let window = UIWindow(frame: UIScreen.main.bounds)
window.backgroundColor = .white
window.rootViewController = UINavigationController(rootViewController: ViewController())
window.makeKeyAndVisible()
return true
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>使用代码初始化 Storyboard 中的 ViewController</title>
    <url>/2016/11/23/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B%E5%8C%96-Storyboard-%E4%B8%AD%E7%9A%84-ViewController/</url>
    <content><![CDATA[<ol>
<li>打开Storyboard 文件，找到你需要初始化的 ViewController，将它的 Storyboard ID 设置为一个唯一标志，这里使用“StoryboardVCPush”，不同于其他的 Storyboard ID</li>
<li>使用如下代码跳转至新的 ViewController</li>
</ol>
<pre><code class="swift">let storyBoard = UIStoryboard(name: &quot;Main&quot;, bundle: .main)
let vc = storyBoard.instantiateViewController(withIdentifier:&quot;StoryboardVCPush&quot;)
self.navigationController?.pushViewController(vc, animated: true)
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>分页列表加载丢失数据的问题分析</title>
    <url>/2022/04/25/%E5%88%86%E9%A1%B5%E5%88%97%E8%A1%A8%E5%8A%A0%E8%BD%BD%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>关于分页列表的获取，如果存在多端操作，很有可能出现数据重复或者丢失的情况<br>这里以两张图作为说明<br><img src="/2022/04/25/%E5%88%86%E9%A1%B5%E5%88%97%E8%A1%A8%E5%8A%A0%E8%BD%BD%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1.jpg"></p>
<p>这个是重复的情况，假如我们在获取第一页的数据后，后台新增了两条数据，那么原来处于第一页的”7“、”6“，两条数据就被划分到第二页了，我们接着请求第二页的时候，就会造成数据的重复（7、6又返回了给了前端），处理方式也比较简单，每条数据增加一个唯一Id，然后前端去重即可</p>
<p>第二种数据丢失的情况<br><img src="/2022/04/25/%E5%88%86%E9%A1%B5%E5%88%97%E8%A1%A8%E5%8A%A0%E8%BD%BD%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/2.jpg"></p>
<p>同样的，在我们请求完第一页的数据后，后台删掉了第一页中的”6“，就会造成原本在第二页里的”5“，变成了第一页，我们在拉取第二页数据的时候，就拿不到”5“了，造成了数据的丢失，这种情况，对于 http 网络请求来说，前端是没办法处理的，只能尽量规避。</p>
]]></content>
  </entry>
  <entry>
    <title>半透明图层的滤色混合</title>
    <url>/2022/08/19/%E5%8D%8A%E9%80%8F%E6%98%8E%E5%9B%BE%E5%B1%82%E7%9A%84%E6%BB%A4%E8%89%B2%E6%B7%B7%E5%90%88/</url>
    <content><![CDATA[<p>网上有一些现成的方法，大致的思想都是两个颜色加权平均，权重则依据透明度来计算，这里使用了一种最简单的方式</p>
<p>color &#x3D; imageColor * (1 - mask.alpha) + maskColor * mask.alpha</p>
<p>最终的效果还是比较不错的，如图所示</p>
<p><img src="/2022/08/19/%E5%8D%8A%E9%80%8F%E6%98%8E%E5%9B%BE%E5%B1%82%E7%9A%84%E6%BB%A4%E8%89%B2%E6%B7%B7%E5%90%88/1.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>图片resize导致分辨率变化的问题</title>
    <url>/2022/11/02/%E5%9B%BE%E7%89%87resize%E5%AF%BC%E8%87%B4%E5%88%86%E8%BE%A8%E7%8E%87%E5%8F%98%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>使用 qmui_imageResized 来修改图片尺寸，在某些情况下会出现相差一个像素的问题，导致错误发生。</p>
<p>可以使用<br><img src="/2022/11/02/%E5%9B%BE%E7%89%87resize%E5%AF%BC%E8%87%B4%E5%88%86%E8%BE%A8%E7%8E%87%E5%8F%98%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98/1.jpg"></p>
<p>或<br><img src="/2022/11/02/%E5%9B%BE%E7%89%87resize%E5%AF%BC%E8%87%B4%E5%88%86%E8%BE%A8%E7%8E%87%E5%8F%98%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98/2.jpg"></p>
<p>这两种方式来进行尺寸修改，推荐使用第一种，因为它处理尺寸的同时也处理了 bitmap 的格式，可以看到文档中已经进行了说明<br>&#x2F;&#x2F; The following methods will only return a 8-bit per channel context in the DeviceRGB color space.<br>&#x2F;&#x2F; Any new bitmap drawing code is encouraged to use UIGraphicsImageRenderer in lieu of this API.</p>
]]></content>
  </entry>
  <entry>
    <title>向 iOS App 中添加 Flutter 界面</title>
    <url>/2021/01/28/%E5%90%91-iOS-App-%E4%B8%AD%E6%B7%BB%E5%8A%A0-Flutter-%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>想要实现该功能，打交道比较频繁的就只有两个类，</p>
<ul>
<li>FlutterEngine</li>
<li>FlutterViewController</li>
</ul>
<p>官方文档中有段话</p>
<pre><code>The FlutterEngine serves as a host to the Dart VM and your Flutter runtime,
and the FlutterViewController attaches to a FlutterEngine to pass UIKit input
events into Flutter and to display frames rendered by the FlutterEngine.
</code></pre>
<p>大意是，Flutter Engine 代表着你当前的 Flutter App，</p>
<p>FlutterViewController 则是将 iOS App 和 Flutter App 链接起来的桥梁。</p>
<p>在我们从原生跳转至 Flutter 界面时，如果没有指定 FlutterEngine，那么 FlutterViewController 会隐式地创建一个，相当于新运行了一个我们的 Flutter App。它与原来的 App 是无关的。</p>
<p>所以这就是为什么按照先前的方式跳转，我们进入购买页没有数据的原因。</p>
<p>目前有三种跳转方案，</p>
<ol>
<li>使用 FlutterEngine 创建一个新的 FlutterViewController，它与我们原来的 App 共享运行时环境。</li>
<li>直接使用 window.rootViewController（即 FlutterViewController），这个就是我们原来的 Flutter App 界面。</li>
<li>创建新的 FlutterEngine，然后跳转的时候把所需的参数传过去（参数如果太复杂则不建议）</li>
</ol>
<p>最后通过 FlutterViewController.pushRoute 方来来进入所需的界面。</p>
]]></content>
  </entry>
  <entry>
    <title>坐标系统</title>
    <url>/2015/12/03/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="火星坐标"><a href="#火星坐标" class="headerlink" title="火星坐标"></a>火星坐标</h2><p>一种处理后的经纬度坐标，处理后的坐标才能与国内地图匹配，否则计算出的位置有偏差</p>
<h2 id="GCJ-02"><a href="#GCJ-02" class="headerlink" title="GCJ-02"></a>GCJ-02</h2><p>一种坐标加密算法，用于处理 GPS 坐标，使之与国内地图匹配</p>
<h2 id="GPS坐标"><a href="#GPS坐标" class="headerlink" title="GPS坐标"></a>GPS坐标</h2><p>从设备获取到的经纬度坐标</p>
<h2 id="WGS84"><a href="#WGS84" class="headerlink" title="WGS84"></a>WGS84</h2><p>全球坐标系统，也是 GPS 使用的坐标系统</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>国内的地图由于特殊需要，必须通过国家测绘局（GCJ）处理后方可出版使用，处理后的地图直接使用 GPS 坐标计算位置，是有偏差的，必须使用 GCJ-02 算法处理成火星坐标，才能计算出正确的位置。</p>
]]></content>
  </entry>
  <entry>
    <title>如何使旋转更加跟手</title>
    <url>/2023/02/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E6%97%8B%E8%BD%AC%E6%9B%B4%E5%8A%A0%E8%B7%9F%E6%89%8B/</url>
    <content><![CDATA[<p>使用鼠标控制旋转角度时，可以通过向量的叉乘计算旋转角度，通过记录控件中心点，鼠标按下时的位置，鼠标当前的位置三个点的信息，形成两个向量，最终通过叉乘得到旋转的角度信息</p>
<pre><code class="swift">@objc func on_pan(pan: UIPanGestureRecognizer) &#123;
    let touch_point = pan.location(in: self.view)
    let center = self.view.center
    if pan.state == .began &#123;
        start_point = touch_point
        start_transform = self.red_view.transform
    &#125; else if pan.state == .changed &#123;
        let v_old = CGPoint(x: start_point.x - center.x, y: start_point.y - center.y)
        let v_new = CGPoint(x: touch_point.x - center.x, y: touch_point.y - center.y)
        
        let v_old_length = sqrt(pow(v_old.x, 2) + pow(v_old.y, 2))
        let v_new_length = sqrt(pow(v_new.x, 2) + pow(v_new.y, 2))
        
        let angle = acos((v_old.x * v_new.x + v_new.y * v_old.y) / v_old_length / v_new_length)
        
        self.red_view.transform = start_transform.concatenating(.init(rotationAngle: angle))
    &#125; else if pan.state == .ended &#123;
        start_point = .zero
        start_transform = .identity
    &#125;
&#125;
</code></pre>
<p>但是有一个问题，只能识别出 0~180 度的旋转角度</p>
<p>可以通过增加一个辅助向量 （0,1），然后分别计算两个向量与它的夹角，同时判断两个向量所在的位置（左半边还是右半边）来得到 0~360 度的旋转角度，代码如下</p>
<pre><code class="swift">@objc func on_pan(pan: UIPanGestureRecognizer) &#123;
    let touch_point = pan.location(in: self.view)
    let center = self.view.center
    if pan.state == .began &#123;
        start_point = touch_point
        start_transform = self.red_view.transform
    &#125; else if pan.state == .changed &#123;
        // 三个向量
        let v_norm = CGPoint(x: 0, y: -1)
        let v_old = CGPoint(x: start_point.x - center.x, y: start_point.y - center.y)
        let v_new = CGPoint(x: touch_point.x - center.x, y: touch_point.y - center.y)
        
        // 向量的长度
        let v_old_length = sqrt(pow(v_old.x, 2) + pow(v_old.y, 2))
        let v_new_length = sqrt(pow(v_new.x, 2) + pow(v_new.y, 2))
        
        // 向量的夹角
        let angle_old = acos((v_old.x * v_norm.x + v_old.y * v_norm.y) / v_old_length)
        let angle_new = acos((v_new.x * v_norm.x + v_new.y * v_norm.y) / v_new_length)
        let angle_vv = acos((v_old.x * v_new.x + v_new.y * v_old.y) / v_old_length / v_new_length)
        
        // 旋转角度计算
        var angle: CGFloat = 0
        if v_old.x &gt;= 0 &amp;&amp; v_new.x &gt;= 0 &#123;
            // 两个向量在又半边
            angle = angle_new - angle_old
        &#125; else if v_old.x &gt;= 0 &amp;&amp; v_new.x &lt; 0 &#123;
            // 两个向量在不同的两边
            if angle_old + angle_new &gt;= .pi &#123;
                angle = angle_vv
            &#125; else &#123;
                angle = .pi * 2 - angle_vv
            &#125;
        &#125; else if v_old.x &lt; 0 &amp;&amp; v_new.x &gt;= 0 &#123;
            // 两个向量在不同的两边
            if angle_old + angle_new &gt;= .pi &#123;
                angle = .pi * 2 - angle_vv
            &#125; else &#123;
                angle = angle_vv
            &#125;
        &#125; else if v_old.x &lt; 0 &amp;&amp; v_new.x &lt; 0 &#123;
            // 两个向量均在左半边
            angle = angle_old - angle_new
        &#125;

        self.red_view.transform = start_transform.concatenating(.init(rotationAngle: angle))
    &#125; else if pan.state == .ended &#123;
        start_point = .zero
        start_transform = .identity
    &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>如何制作无限滑动的 ScrollView</title>
    <url>/2016/01/10/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E6%97%A0%E9%99%90%E6%BB%91%E5%8A%A8%E7%9A%84-ScrollView/</url>
    <content><![CDATA[<p>公司需要制作一个地图控件，要求不使用系统的 MapKit，那么只能使用 UIScrollView 来自己实现了<br>地图是由一个一个“瓦片”拼接而成，可以以某个经纬度为中心点，向周围个扩展5个瓦片，这样总计7x7个瓦片添加到 UIScrollView 中，当用户向某个方向滑动满一格的距离时，通过代码将其拉回中心点，同时更新各个瓦片的内容即可.<br>经过验证发现，直接修改 contentOffset 属性，可以在改变 contentOffset 的同时，保留滑动速度，这样只要我们更新地图瓦片内容，用户也感觉不出来，可行。</p>
<h3 id="Demo-效果如下"><a href="#Demo-效果如下" class="headerlink" title="Demo 效果如下"></a>Demo 效果如下</h3><p><img src="/2016/01/10/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E6%97%A0%E9%99%90%E6%BB%91%E5%8A%A8%E7%9A%84-ScrollView/1.gif"></p>
<h3 id="加上地图瓦片后效果如下"><a href="#加上地图瓦片后效果如下" class="headerlink" title="加上地图瓦片后效果如下"></a>加上地图瓦片后效果如下</h3><p><img src="/2016/01/10/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E6%97%A0%E9%99%90%E6%BB%91%E5%8A%A8%E7%9A%84-ScrollView/2.gif"></p>
<h3 id="源代码如下"><a href="#源代码如下" class="headerlink" title="源代码如下"></a>源代码如下</h3><pre><code class="swift">class ViewController: UIViewController, UIScrollViewDelegate &#123;
    let scroll_view = UIScrollView()
    let length = 200.0
        
    var center = CGPoint(x: 13399, y: 6733)
    
    override func viewDidLoad() &#123;
        super.viewDidLoad()
        view.backgroundColor = .white
        
        let status_bar_height: CGFloat
        if #available(iOS 13, *) &#123;
            status_bar_height = 0
        &#125; else &#123;
            status_bar_height = UIApplication.shared.statusBarFrame.height
        &#125;
        
        let navigation_bar_height = self.navigationController?.navigationBar.frame.height ?? 0
        let top = status_bar_height + navigation_bar_height
        
        self.scroll_view.contentInsetAdjustmentBehavior = .never
        self.scroll_view.showsVerticalScrollIndicator = false
        self.scroll_view.showsHorizontalScrollIndicator = false
        self.scroll_view.frame = .init(x: 0,
                                       y: top,
                                       width: self.view.frame.width,
                                       height: self.view.frame.height - top)
        self.scroll_view.delegate = self
        self.scroll_view.contentSize = .init(width: length * 7, height: length * 7)
        self.scroll_view.contentOffset = .init(
            x: length * 3.5 - self.view.frame.width / 2,
            y: length * 3.5 - (self.view.frame.height - top) / 2
        )
        self.view.addSubview(self.scroll_view)
        
        update_cell()
    &#125;
    
    func update_cell() &#123;
        for x in -3...3 &#123;
            for y in -3...3 &#123;
                let tag = 100 + 10 * x + y
                var cell = self.scroll_view.viewWithTag(tag) as? MapCell
                if cell == nil &#123;
                    cell = MapCell(frame: .init(
                        x: Double(x + 3) * length,
                        y: Double(y + 3) * length,
                        width: length,
                        height: length
                    ))
                    cell!.tag = tag
                    self.scroll_view.addSubview(cell!)
                &#125;
                let coordinate = CGPoint(x: center.x + CGFloat(x), y: center.y + CGFloat(y))
                cell?.set_coordinate(coordinate: coordinate)
            &#125;
        &#125;
    &#125;
    
    func scrollViewDidScroll(_ scrollView: UIScrollView) &#123;
        let offset = scrollView.contentOffset
        let size = scrollView.contentSize
        let frame_size = scrollView.frame.size
        
        var need_update_cell = false
        if offset.x &lt; (size.width - frame_size.width) / 2 - length &#123;
            scrollView.contentOffset = .init(x: (size.width - frame_size.width) / 2,
                                             y: self.scroll_view.contentOffset.y)
            center = .init(x: center.x - 1, y: center.y)
            need_update_cell = true
        &#125;
        
        if offset.x &gt; (size.width - frame_size.width) / 2 + length &#123;
            scrollView.contentOffset = .init(x: (size.width - frame_size.width) / 2,
                                             y: self.scroll_view.contentOffset.y)
            center = .init(x: center.x + 1, y: center.y)
            need_update_cell = true
        &#125;

        if offset.y &lt; (size.height - frame_size.height) / 2 - length &#123;
            scrollView.contentOffset = .init(x: self.scroll_view.contentOffset.x,
                                             y: (size.height - frame_size.height) / 2)
            center = .init(x: center.x, y: center.y - 1)
            need_update_cell = true
        &#125;
        
        if offset.y &gt; (size.height - frame_size.height) / 2 + length &#123;
            scrollView.contentOffset = .init(x: self.scroll_view.contentOffset.x,
                                             y: (size.height - frame_size.height) / 2)
            center = .init(x: center.x, y: center.y + 1)
            need_update_cell = true
        &#125;
        
        if need_update_cell &#123;
            update_cell()
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>当我们调用 setState 的时候，flutter 做了啥？</title>
    <url>/2021/11/10/%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-setState-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8Cflutter-%E5%81%9A%E4%BA%86%E5%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<p>为了更清晰的说明，将整个过程分为两部分</p>
<h2 id="一、请求新帧"><a href="#一、请求新帧" class="headerlink" title="一、请求新帧"></a>一、请求新帧</h2><ol>
<li>调用 Element.markNeedsBuild</li>
<li>调用 BuildOwner.scheduleBuildFor</li>
<li>调用 BuildOwner.onBuildSchedule</li>
<li>调用 WidgetsBinding._handleBuildScheduled</li>
<li>调用 WidgetsBinding.ensureVisualUpdate，此时如果当前没有新帧的时候，会继续调用</li>
<li>调用 WidgetsBinding.scheduleFrame</li>
<li>调用 ui.window.scheduleFrame</li>
<li>最后调用 PlatformConfiguraion_scheduleFrame，调用了该方法后，系统会在合适的时候调用 <strong>WidgetsBinding._handleBeginFrame</strong> 与 <strong>WidgetsBinding._handleDrawFrame</strong> 这两个方法执行后，就会产生一个新帧，同时会继续调用第 5 步进行循环</li>
</ol>
<p>可以看到，每次调用 setState，都会向系统请求一个新帧。</p>
<p>回到 WidgetsBinding._handleDrawFrame 方法，在里面他会调用 _postFrameCallbacks 中的 callback。这一部分结束。</p>
<h2 id="二、刷新-Widget"><a href="#二、刷新-Widget" class="headerlink" title="二、刷新 Widget"></a>二、刷新 Widget</h2><p>WidgetsBinding 混入了多个 mixin，其中有一个是 RenderBinding。</p>
<p>在初始化的时候，它会调用<br><strong>addPersistentFrameCallback(_handlePersistentFrameCallback);</strong></p>
<p>结合第一部分，每次我们调用 setState 的时候** _handlePersistentFrameCallback** 都会调用。</p>
<p>它调用了 <strong>WidgetsBindings.drawFrame</strong> 方法</p>
<p>该方法又调用了 <strong>BuildOwner.buildScope</strong> 方法对 Widget 进行刷新。</p>
<p>到此基本流程已经结束。里面还有需要更深层次的东西还需要我们慢慢进行发掘。</p>
]]></content>
  </entry>
  <entry>
    <title>带阴影图片保存时间优化</title>
    <url>/2022/09/08/%E5%B8%A6%E9%98%B4%E5%BD%B1%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>今天解决了个遗留 bug，保存带有阴影的图片时，如果放大倍数很高，会花费很久的时间，检查后，主要卡在了这个地方。<br><img src="/2022/09/08/%E5%B8%A6%E9%98%B4%E5%BD%B1%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/1.jpg"></p>
<p>经过测试，应该是由于这个函数，采用了先绘制，在裁剪的方式，导致了超出显示范围的部分也占用了资源，从而花费了很多不必要的时间，查找资料后，发现可以使用这个方法进行裁剪与绘制操作<br><img src="/2022/09/08/%E5%B8%A6%E9%98%B4%E5%BD%B1%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/2.jpg"><br>然后将他们的效果进行了下对比（上图为旧方法，下图为新方法）<br><img src="/2022/09/08/%E5%B8%A6%E9%98%B4%E5%BD%B1%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/3.jpg"><br><img src="/2022/09/08/%E5%B8%A6%E9%98%B4%E5%BD%B1%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/4.jpg"></p>
<p>可以看出，新方法保存的图像更加平滑一些，随后又进行了性能对比<br><img src="/2022/09/08/%E5%B8%A6%E9%98%B4%E5%BD%B1%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/5.jpg"><br>可以看出，在放大倍数比较小情况下，旧方法时间比新方法短，放大倍数比较大的情况下，旧方法的执行时间远大于新方法，新方法执行时长基本在0.1 秒左右，可以接受，故采用新方法进行图片保存。</p>
]]></content>
  </entry>
  <entry>
    <title>循环引用检测</title>
    <url>/2018/04/11/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h3 id="使用-Instruments-gt-Leaks"><a href="#使用-Instruments-gt-Leaks" class="headerlink" title="使用 Instruments -&gt; Leaks"></a>使用 Instruments -&gt; Leaks</h3><p><img src="/2018/04/11/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E6%A3%80%E6%B5%8B/1.png"></p>
<h3 id="特别要注意的点"><a href="#特别要注意的点" class="headerlink" title="特别要注意的点"></a>特别要注意的点</h3><ol>
<li>单向依赖</li>
<li>反向依赖使用 weak</li>
<li>undoManager 回调加上 weak</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>改善App性能</title>
    <url>/2018/10/23/%E6%94%B9%E5%96%84App%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过</p>
<ul>
<li>搜集用户所遇到的问题的信息</li>
<li>监测 App 的行为以找到问题的原因</li>
<li>拟定并实现改进方案</li>
<li>观察方案是否有效的解决了问题</li>
</ul>
<p>通过减少资源用量有一下好处</p>
<ul>
<li>减少 App 启动时间</li>
<li>减少内存用量，可以加快应用从后台唤醒的用时</li>
<li>减少磁盘 IO 可以提升 App 的综合性能</li>
<li>减少等待时间与频率，从而提升用户体验</li>
<li>减少电量消耗</li>
</ul>
<h2 id="获取-App-当前的性能信息"><a href="#获取-App-当前的性能信息" class="headerlink" title="获取 App 当前的性能信息"></a>获取 App 当前的性能信息</h2><ul>
<li>使用 Xcode Organizer 可以获取启动时间、用户 UI 未响应，磁盘使用，内存使用和电量使用相关的信息，同时也可以获取到磁盘用量、崩溃信息和电量信息的诊断报告。</li>
<li>使用 MetricKit 可以获取真实用户信息并将数据记录到你自己的工具中（类似于埋点）</li>
<li>从 TestFlight 的反馈中获取</li>
<li>问卷调查</li>
</ul>
<h2 id="确定一个最重要的方面进行改进"><a href="#确定一个最重要的方面进行改进" class="headerlink" title="确定一个最重要的方面进行改进"></a>确定一个最重要的方面进行改进</h2><p>这个往往需要结合 App 的类型进行决定，App 的用途不同，重点指标也不同，例如：一个音乐播放器由于需要在后台不断播放音乐，那么它的电量消耗相对于其他指标就没有那么重要。</p>
<h2 id="监测-App"><a href="#监测-App" class="headerlink" title="监测 App"></a>监测 App</h2><p>可以使用 Instruments 提供的一系列工具</p>
<ul>
<li>Time Profiler，同来测量时间指标，例如应用未响应的情况</li>
<li>Allocations 和 Leaks 用于监测内存用量</li>
<li>Energy Log 用于监测电量用量</li>
<li>File Activity 用于监测磁盘 IO</li>
<li>Network template 用于监测网络</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>放大带阴影图片导致崩溃问题的解决方法</title>
    <url>/2022/09/05/%E6%94%BE%E5%A4%A7%E5%B8%A6%E9%98%B4%E5%BD%B1%E5%9B%BE%E7%89%87%E5%AF%BC%E8%87%B4%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天解决了在带有阴影的情况下，放大图片到一定程度，App 会闪退的问题。</p>
<p>过程还比较顺利，目前的阴影是通过设置 layer.shadow 相关的参数实现的，通过 shadowColor，shadowOffset，shadowRadius等来设置阴影的颜色，偏移量以及大小。</p>
<p>每当图片缩放后，系统会重新计算阴影，造成了比较大的开销，通过查阅 CALayer 类的各个属性，发现了这么一个东西。<br><img src="/2022/09/05/%E6%94%BE%E5%A4%A7%E5%B8%A6%E9%98%B4%E5%BD%B1%E5%9B%BE%E7%89%87%E5%AF%BC%E8%87%B4%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/1.jpg"></p>
<p>简单来说就是系统会把计算出的阴影存为 bitmap，每次更新不需要再重新计算阴影了，性能一下就上来了。</p>
]]></content>
  </entry>
  <entry>
    <title>日期格式化字符串与一个有趣的bug</title>
    <url>/2021/12/28/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84bug/</url>
    <content><![CDATA[<p>今天遇到一个神奇的问题<br><img src="/2021/12/28/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84bug/1.jpg"><br>猜猜他们输出是啥<br><img src="/2021/12/28/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84bug/2.jpg"><br>怎么到 2022 年去了，我明明使用的 Date() 对象（也就是代表了今天的日期）</p>
<p><strong>问题原因</strong></p>
<p>为什么 YYYY-MM-dd 格式化 2021 年 12 月 28 日的时候，会到 2022 年呢？</p>
<p>因为 YYYY 是 week-based-year，表示：当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，那么这周就算入下一年。</p>
<p>所以 2021 年 12 月 28 日那天在这种表述方式下就已经到 2022 年了。<br>而当使用 yyyy 的时候，就还是 2021 年。</p>
<p>这个问题告诉我们，大小写还是十分重要的。</p>
<p>日期格式化字符串有趣的用法</p>
<p>这里以一个表格为例，时间为 2021-12-30 23:05:00</p>
<p>代码如下</p>
<pre><code class="swift">let fmt = DateFormatter()
fmt.locale = Locale(identifier: &quot;zh-CN&quot;)
fmt.dateFormat = “some value&quot;
print(fmt.string(from:Date()))
</code></pre>
<p>some value 与 输出对照表</p>
<table>
<thead>
<tr>
<th align="center">some value</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GGG</td>
<td align="center">公元 or 公元前</td>
</tr>
<tr>
<td align="center">EEE</td>
<td align="center">周四</td>
</tr>
<tr>
<td align="center">qqqq</td>
<td align="center">第四季度</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">MM</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">MMM</td>
<td align="center">12月</td>
</tr>
<tr>
<td align="center">MMMM</td>
<td align="center">十二月</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">52（本周是今年的第几周）</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">4（本周是本月的第几周）</td>
</tr>
<tr>
<td align="center">d or dd</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">D or DD or DDD</td>
<td align="center">364（今天是今年的第几天）</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">5（今天所在的周是本月的第几周）</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">5（今天是本周的第几天，周日为第一天）</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">下午（上午 or 下午）</td>
</tr>
<tr>
<td align="center">h</td>
<td align="center">11（12小时制，范围为1-12）</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">23（24小时制，范围为0-23）</td>
</tr>
<tr>
<td align="center">k</td>
<td align="center">23（24小时制，范围是1-24）</td>
</tr>
<tr>
<td align="center">K</td>
<td align="center">11（12小时制，范围是0-11）</td>
</tr>
<tr>
<td align="center">m or mm</td>
<td align="center">5 or 05 （分钟）</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">秒</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">毫秒</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">83281917（当天的毫秒级时间戳）</td>
</tr>
</tbody></table>
<p>还有更多的用法，可以查看这个地方</p>
<p><a href="http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns">http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns</a></p>
]]></content>
  </entry>
  <entry>
    <title>本周工作回顾</title>
    <url>/2021/05/25/%E6%9C%AC%E5%91%A8%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>回顾这周的工作，有做的好的地方，也有做的不足的地方。</p>
<p>好的地方在于主动推动了字体库需求的开发进度，协调多方面的人员来完成这个功能，<br>不足在于作为移动端开发人员，对于其他端所需做的事情不够了解，很多时候以为已经协调好了，实际上还是缺一点，需要跟进的更频繁一些。但是如何协调好自己的开发工作与这类事情，还需要进一步的研究。</p>
<p>目前已知的问题是，越接近发布节点，暴露的问题越多，事情越多，但是为了避免延期，又不得不降低某些需求的标准，或者将某些需求移到下一个版本去实现，这样是很不好的。<br>这些问题都是等到打包验收了才暴露出来，由此可见，产品看到了实际交付的App -&gt; 发现了需求中不完善的地方 -&gt; 更新需求 -&gt; 开始优化，此时时间已经是不足点的状态了，为了工期，不得不在某些地方进行裁剪，可能是牺牲程序后续的可维护性，可能是牺牲性能，也可能是阉割掉某些不重要的功能。</p>
<p>目前我们需求评审机制还不够完善，无法很好地体现出需求中的缺陷，需求中的不一致性，根本原因是产品需求（用户需求）和系统需求（功能需求）可能并不一致，由于自然语言的二义性，在表达时，可能会导致我们所理解的和产品所要表达的不一致。进而导致开发出错误的或者是不完善的功能。虽然有了原型文档，但是这样不够直白，例如字体库需求的表述，就没办法处理很多实际开中遇到的问题（例如字体预览只有在字体下载完成后才能看到，导致字体按钮的文案样式都是一样的，实际这一块应该由字体预览图来实现）等等。</p>
<p>下一步我们要做的就是，增量式交付，在需求出来后，不必等到全部开发完成后才交付于测试或者产品，在我们完成部分核心功能后，即可提交一个版本给产品来验证需求的一致性，是否满足他所需要的需求，这个原型版本可以不美观，甚至可以有点丑，但是核心功能是完备的，产品拿到了这个版本，验证它是否合乎自己提出的需求，或者会发现某些地方需要修改，提前发现了问题，这样就降低了最终版本发布时的风险。</p>
]]></content>
  </entry>
  <entry>
    <title>瓦片地图缓存</title>
    <url>/2016/01/21/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>目前有两个场景需要优化，由于地图瓦片每一次都会从网络加载</p>
<ol>
<li>用户网络不好的情况下，可能会出现地图无法显示的情况</li>
<li>用户不断滑动地图的情况下，会不断地加载相同的地图内容，浪费大量网络流量，也会影响加载速度<br>所以需要提供缓存功能<br>由于每个瓦片的 url 都有不同的xyz坐标，所以可以使用 url 作为key来保存或读取缓存图片，代码如下</li>
</ol>
<pre><code class="swift">class Cache &#123;
    private var cache: [String: UIImage] = [:]
    
    static let shared = Cache()
        
    func get_image(key: String) -&gt; UIImage? &#123;
        return self.cache[key]
    &#125;
    
    func set_image(key: String, image: UIImage) &#123;
        self.cache[key] = image
    &#125;
&#125;
</code></pre>
<p>使用一个单例来管理缓存，使用字典来保存缓存数据<br>但是这样会有一个问题，如果缓存的图片非常多的时候，会造成内存使用量增加，这个时候可以使用内存缓存+磁盘缓存结合的方式，在沙盒目录中创建一个文件夹，作为磁盘缓存用来存放地图图片，同时设置一个内存缓存上限，如果当前的内存缓存超出了这个上限之后，将一部分的内存缓存放到磁盘缓存中去，用户读取缓存的时候，按照内存-&gt;磁盘的顺序读取缓存，读取磁盘缓存的时候，同时将其加载到内存缓存中。每次内存缓存数量超出上限后，采用先进先出的队列顺序处理内存缓存，修改后的代码如下</p>
<pre><code class="swift">class MapCache &#123;
    private let max_key_length = 100
    private let cache_dir: String
            
    private var key_list: [String] = []
    private var cache_dic: [String: UIImage] = [:]

    init() &#123;
        let document_path = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).last!
        self.cache_dir = &quot;\(document_path)/Cache/MapTile&quot;
        if FileManager.default.fileExists(atPath: self.cache_dir) == false &#123;
            try? FileManager.default.createDirectory(atPath: self.cache_dir, withIntermediateDirectories: true)
        &#125;
    &#125;
    
    func get_image(key: String) -&gt; UIImage? &#123;
        if let image = self.cache_dic[key] &#123;
            return image
        &#125;
        let cache_file_path = &quot;\(self.cache_dir)/\(key).png&quot;
        if let image = UIImage(contentsOfFile: cache_file_path) &#123;
            self.key_list.append(key)
            self.cache_dic[key] = image
            if self.key_list.count &gt; self.max_key_length &#123;
                let remove_key = self.key_list.removeFirst()
                self.cache_dic.removeValue(forKey: remove_key)
            &#125;
        &#125;
        return nil
    &#125;
    
    func set_image(key: String, image: UIImage) &#123;
        self.key_list.append(key)
        self.cache_dic[key] = image
        if self.key_list.count &gt; self.max_key_length &#123;
            let remove_key = self.key_list.removeFirst()
            self.cache_dic.removeValue(forKey: remove_key)
        &#125;
        if let data = image.pngData() &#123;
            let path = &quot;\(self.cache_dir)/\(key).png&quot;
            let url = URL(filePath: path)
            try? data.write(to: url)
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>监听 present VC 下拉消失事件</title>
    <url>/2023/02/09/%E7%9B%91%E5%90%AC-present-VC-%E4%B8%8B%E6%8B%89%E6%B6%88%E5%A4%B1%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>可以通过 UIAdaptivePresentationControllerDelegate 的两个方法</p>
<p>func presentationControllerShouldDismiss(_ presentationController: UIPresentationController) -&gt; Bool</p>
<p>func presentationControllerDidAttemptToDismiss(_ presentationController: UIPresentationController)</p>
<p>当 presentationControllerShouldDismiss 返回 true 的时候允许下拉 dismiss VC，且不会触发 presentationControllerDidAttemptToDismiss 回调方法</p>
<p>当 presentationControllerShouldDismiss 返回 false 的时候不允许下拉 dismiss VC，下拉到一定的距离后松手会回弹，且会触发 presentationControllerDidAttemptToDismiss 回调方法</p>
<p>完整示例代码如下<br><img src="/2023/02/09/%E7%9B%91%E5%90%AC-present-VC-%E4%B8%8B%E6%8B%89%E6%B6%88%E5%A4%B1%E4%BA%8B%E4%BB%B6/1.png"></p>
]]></content>
  </entry>
  <entry>
    <title>编译报错解决方法</title>
    <url>/2022/03/11/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>当我们对 App 进行打包时，如果出现了如下错误<br><img src="/2022/03/11/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/1.jpg"></p>
<p>或者类似的 One of the two will be used … 可以尝试各个依赖库的部署版本以及 Podfile 中指定的版本是否一致，修改为同一版本后可以修复该问题</p>
]]></content>
  </entry>
  <entry>
    <title>获取相机的图片数据流</title>
    <url>/2022/10/12/%E8%8E%B7%E5%8F%96%E7%9B%B8%E6%9C%BA%E7%9A%84%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%B5%81/</url>
    <content><![CDATA[<p>通过使用 AVCaptureSession 可以很方便的捕获相机的数据流，只需要配置好输入与输出，<br><img src="/2022/10/12/%E8%8E%B7%E5%8F%96%E7%9B%B8%E6%9C%BA%E7%9A%84%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%B5%81/1.jpg"></p>
<p>然后通过回调方法获取到 CMSampleBufferRef 对象，它代表了相机捕获到的每一帧图像数据<br><img src="/2022/10/12/%E8%8E%B7%E5%8F%96%E7%9B%B8%E6%9C%BA%E7%9A%84%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%B5%81/2.png"></p>
<p>最后转换成 CIImage 就可以很方便地使用 CoreImage 对其进行处理了<br><img src="/2022/10/12/%E8%8E%B7%E5%8F%96%E7%9B%B8%E6%9C%BA%E7%9A%84%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%B5%81/3.png"></p>
]]></content>
  </entry>
  <entry>
    <title>视频下载神器</title>
    <url>/2021/11/23/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<p>想看视频却找不到下载链接？用它就够了，一个非常简洁，但是功能十分强大的网络视频下载器</p>
<p><a href="https://github.com/soimort/you-get">https://github.com/soimort/you-get</a></p>
]]></content>
  </entry>
  <entry>
    <title>视频对比脚本</title>
    <url>/2022/04/10/%E8%A7%86%E9%A2%91%E5%AF%B9%E6%AF%94%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>macOS Command Line Tool 截取视频中的某一帧的方法</p>
<pre><code class="swift">import Foundation
import AVFoundation

let url = URL(fileURLWithPath: &quot;/Users/huangrui/Desktop/1.mp4&quot;)
let asset = AVURLAsset(url: url)
let generator = AVAssetImageGenerator(asset: asset)
let duration: CMTime = asset.duration
let cgImage = try? generator.copyCGImage(at: CMTime(value: 1000, timescale: 1000), actualTime: nil)
let targetUrl = URL(fileURLWithPath: &quot;/Users/huangrui/Desktop/123.png&quot;)
let destination = CGImageDestinationCreateWithURL(targetUrl as CFURL, kUTTypePNG, 1, nil)
CGImageDestinationAddImage(destination!, cgImage!, nil)
let isSuccess = CGImageDestinationFinalize(destination!)
print(isSuccess)
</code></pre>
<p>CMTime 是个结构体，其中有两个属性需要关注，一个是 value，另一个是 timescale，他们的关系是</p>
<p>value&#x2F;timescale &#x3D; seconds</p>
<p>视频对比实现的方案比较简单，通过 AVAssetImageGenerator 截取两个视频相同时间点的画面，然后通过 OpenCV 获取到对应画面的像素点信息，使用均值哈希算法计算图片指纹进行比较，最后根据每一帧画面的比较结果，绘制出直方图输出（其中，横轴是时间，纵轴是相似率）。</p>
<p>均值哈希算法，它是感知哈希算法中最简单的一种，基本原理是对图片降频。对于图片，高频有很多细节，如颜色、亮度、透明度等等，而低频丢弃细节，只有图像结构，优点是计算简单，速度非常快。这里直接引用网址吧（<a href="https://baike.baidu.com/item/%E5%9D%87%E5%80%BC%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/18839330">均值哈希</a>）</p>
<p>目前测试了三种情况。</p>
<p>第一种：自己与自己比较</p>
<p>输出结果：<br><img src="/2022/04/10/%E8%A7%86%E9%A2%91%E5%AF%B9%E6%AF%94%E8%84%9A%E6%9C%AC/1.jpg"></p>
<p>完全一致</p>
<p>第二种：与仅互换了第二个第三个画面位置的视频比较</p>
<p>输出结果：<br><img src="/2022/04/10/%E8%A7%86%E9%A2%91%E5%AF%B9%E6%AF%94%E8%84%9A%E6%9C%AC/2.jpg"></p>
<p>可以看到，前面有点不一样，后续是一样的，与预期相符</p>
<p>第三种，与仅修改了第三个画面的文案的视频进行对比</p>
<p>输出结果：<br><img src="/2022/04/10/%E8%A7%86%E9%A2%91%E5%AF%B9%E6%AF%94%E8%84%9A%E6%9C%AC/3.jpg"></p>
<p>与预期相符。</p>
<p>同时可以使用OpenCV 中的VideoCapture对视频进行逐帧截图，这样就可以不局限于macOS平台了</p>
<p>目前脚本只是简单的对比视频每一帧是否相似，只能满足部分需求，假如遇到视频不对齐的情况，那么从不对齐的时间点开始，后续全部会判定为不相同，导致后续的结果输出不准确。</p>
<p>目前对每一帧的处理方式是：</p>
<ol>
<li>先转缩放至8x8</li>
<li>再传转成灰度</li>
<li>使用均值哈希生成图片指纹</li>
<li>计算两个指纹的汉明距离</li>
<li>设定一个阈值，假如两个图片指纹的汉明距离超过了这个阈值，则判定为不相符</li>
</ol>
<p>但是目前没有办法处理视频没有对齐的情况，后续可以针对这一点进行优化</p>
]]></content>
  </entry>
  <entry>
    <title>记一次有趣的debug经历</title>
    <url>/2022/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84debug%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>项目出现了一个 bug，飞行模式下，弹出加载框后，App 就没办法响应用户的点击事件了，如果是有网络的状态，却没有这个问题。</p>
<p>我们使用的 Loading 库是 EasyLoading。</p>
<p>刚开始的思路是，既然开启飞行模式有问题，不开就正常了，那么应该是出现网络状态处理那里，检查了这一部分代码后仍然没有发现什么问题，Loading 是我们手动控制的，网络状态和它无关。</p>
<p>接着怀疑 Loading 控件本身是否进行了网络状态监听，查看代码后也没发现相关功能。</p>
<p>最后怀疑是否是 Loading 本身阻止了用户的手势。</p>
<p>在 flutter 中想展示一个透明控件有两种方式</p>
<pre><code class="dart">// 1. 设置背景色为透明颜色
Container(color: Colors.transparent);
// 2. 不设置背景色
Container();
</code></pre>
<p>这两种方式都会生成一个透明的控件，但是他们的区别是，第一个控件的透明部分会拦截用户手势，第二个控件的透明部分则不会拦截。</p>
<p>接着去检查 EasyLoading 的相关代码，发现了如下代码<br><img src="/2022/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84debug%E7%BB%8F%E5%8E%86/1.jpg"></p>
<p>简单说明下，它由两个 AnimatedBuilder 组成，上面那个生成背景控件，下面那个生成 Loading 控件，</p>
<p>对属性作下说明</p>
<ul>
<li>_ignoring 作为总开关 - false：如果可以的话，背景控件会响应用户手势；true：背景控件不会响应用户手势</li>
<li>_dismissOnTap - true：点击背景可以使 Loading 消失；false：点击背景不会使 Loading 消失。</li>
</ul>
<p>观察开启与关闭飞行模式时，这两个参数的值</p>
<p>关闭飞行模式（网络正常）</p>
<p>_ignoring &#x3D; true, _dismissOnTap &#x3D; false</p>
<p>开启飞行模式（无网络）</p>
<p>_ignoring &#x3D; false, _dismissOnTap &#x3D; false</p>
<p>开启飞行模式的时候 ignoring 变成了 false，所以 Loading 拦截了用户手势，这一块不正常，不应该变成 false，检查了相关的代码<br><img src="/2022/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84debug%E7%BB%8F%E5%8E%86/2.jpg"><br><img src="/2022/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84debug%E7%BB%8F%E5%8E%86/3.jpg"></p>
<p>简单说明下</p>
<ol>
<li>可以先忽略 ignoring 方法的第一行赋值语句。</li>
<li>maskType 由于没有指定，所以是默认的 .none。</li>
<li>由于最终却返回了 true，那么肯定是因为 EasyLoading.instance.userInteractions &#x3D; true 导致的。</li>
</ol>
<p>现在就得找问题的源头了，为啥飞行模式它是 true，突然想到，在飞行模式状态下开启 App，会在首页提示用户，“当前网络不佳”，查看代码后发现了这个<br><img src="/2022/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84debug%E7%BB%8F%E5%8E%86/4.jpg"></p>
<p>问题找到了，罪魁祸首就是它，由于 EasyLoading.instance 是个单例，所以这样会影响贯穿整个 App，是不正确的，会影响到其他地方的 Loading，应该使用它暴露出来的 API 才对，改成这样后 bug 消失。<br><img src="/2022/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84debug%E7%BB%8F%E5%8E%86/5.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>软件工程 - 图形建模</title>
    <url>/2021/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E5%9B%BE%E5%BD%A2%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h3 id="图形建模通常有三种用途"><a href="#图形建模通常有三种用途" class="headerlink" title="图形建模通常有三种用途"></a>图形建模通常有三种用途</h3><ol>
<li>为讨论现有系统或提出新功能的系统提供便利</li>
<li>论证现有系统</li>
<li>作为详细的系统描述，该描述可用来产生系统实现</li>
</ol>
<h3 id="图形建模的步骤"><a href="#图形建模的步骤" class="headerlink" title="图形建模的步骤"></a>图形建模的步骤</h3><ol>
<li>定义系统边界，上下文模型</li>
<li>交互模型</li>
</ol>
<ul>
<li>用例模型</li>
<li>时序图</li>
</ul>
<ol start="3">
<li>结构模型</li>
</ol>
<ul>
<li>类图</li>
<li>泛化</li>
<li>聚合</li>
</ul>
<ol start="4">
<li>行为模型</li>
</ol>
<ul>
<li>数据驱动，活动图</li>
<li>事件驱动，状态图</li>
</ul>
<h3 id="模型驱动工程"><a href="#模型驱动工程" class="headerlink" title="模型驱动工程"></a>模型驱动工程</h3><p>模型驱动体系结构</p>
<ul>
<li>CIM-计算独立模型，系统中使用的重要的领域抽象模型</li>
<li>PIM-平台独立模型，在没有它的实现作为参考下为系统的运行建模</li>
<li>PSM-平台特定模型，由平台独立模型转化</li>
</ul>
<h3 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h3><ol>
<li>两个抽象层次：</li>
</ol>
<ul>
<li>小规模体系结构</li>
<li>大规模体系结构</li>
</ul>
<ol start="2">
<li>设计和文档化体系结构的好处：</li>
</ol>
<ul>
<li>信息持有者之间的沟通</li>
<li>系统分析</li>
<li>大规模复用</li>
</ul>
<ol start="3">
<li>使用方块图，优点是利于理解，比较直观</li>
</ol>
<h3 id="使用程序的体系结构模型有两种方法"><a href="#使用程序的体系结构模型有两种方法" class="headerlink" title="使用程序的体系结构模型有两种方法"></a>使用程序的体系结构模型有两种方法</h3><ol>
<li>为一种加快系统设计商讨的方法</li>
<li>作为一种对已设计好的体系结构文档化的方法</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>软件工程 - 软件过程</title>
    <url>/2021/07/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>首先，说一下两个开发过程模型：</p>
<ul>
<li><p><strong>瀑布模型</strong> - 该模型将基本的过程活动：描述、开发、有效性验证、进化，看成是一些界限分明的独立的过程阶段，按照顺序来进行开发活动。</p>
</li>
<li><p><strong>增量式开发</strong> - 该方法使得描述活动、开发活动和有效性验证活动交织在一起，系统的开发是建立一系列的版本（或增量），每个版本添加部分功能达到先前的版本中。</p>
</li>
</ul>
<p>目前，右糖的总体开发模式是增量式开发，每个版本都会加入新的功能或者根据需要修改以前的功能。其中的每个版本里使用了瀑布模型来进行迭代</p>
<p>但是上个迭代中各个活动之间又相互穿插，在设计阶段，可能发现需求中的问题；在编程阶段，有可能会发现设计当中的问题，反复确认的成本很高，不利于快速迭代。</p>
<p>由于这个原因，在上个迭代中尝试使用了增量式开发。</p>
<p>增量式开发的思想是先开发一个初始的实现，给用户使用并听取用户的意见和建议，然后通过对多个版本的不断修改直到产生一个充分的系统，它本身就是一个支持变更的开发过程，所以比较适合现在的情况。</p>
<p>但是有两点不足：</p>
<ol>
<li>对增量式开发的使用经验不足，没有落实“初始实现”。任务分解出来的子任务的耦合性太大，导致第一次交付的时间太晚，很难较早地评估系统，找出需要修改的地方。</li>
<li>程序的设计不够完备，而且没有实时更新</li>
</ol>
<p>对于目前的情况来说，我觉得增量式开发是一种很好地方法，需要继续坚持下去，但是我们也需要一段时间的磨合来熟悉这种方式，同时上面两点也是后续开发过程需要注意的地方，相信随着越来越熟练，它带来的好处也会越来越明显。</p>
]]></content>
  </entry>
  <entry>
    <title>软件工程 - 需求工程</title>
    <url>/2021/07/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h3><ul>
<li><strong>需求工程</strong> - 对系统提供的服务和系统的约束的发现、分析、建立文档、检验的过程。</li>
</ul>
<h3 id="用户需求-和-系统需求"><a href="#用户需求-和-系统需求" class="headerlink" title="用户需求 和 系统需求"></a>用户需求 和 系统需求</h3><ul>
<li><strong>用户需求</strong> - 用自然语言加图的形式给出的、关于系统需要提供哪些服务以及系统操作受到哪些约束的声明。</li>
<li><strong>系统需求</strong> - 系统将要提供的服务以及系统所受到的约束。</li>
</ul>
<h3 id="功能需求-和-非功能需求"><a href="#功能需求-和-非功能需求" class="headerlink" title="功能需求 和 非功能需求"></a>功能需求 和 非功能需求</h3><ul>
<li><strong>功能需求</strong> - 描述系统所提供的的功能和服务</li>
<li><strong>非功能需求</strong> - 那些不直接关系到系统向用户提供的具体服务的一类需求。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>重力小球</title>
    <url>/2020/04/19/%E9%87%8D%E5%8A%9B%E5%B0%8F%E7%90%83/</url>
    <content><![CDATA[<h2 id="最终成果：《重力小球》游戏"><a href="#最终成果：《重力小球》游戏" class="headerlink" title="最终成果：《重力小球》游戏"></a>最终成果：《重力小球》游戏</h2><p>倾斜手机使得小球滚动通过重重障碍最终到达目的地</p>
<h2 id="环境配置（macOS、Win）"><a href="#环境配置（macOS、Win）" class="headerlink" title="环境配置（macOS、Win）"></a>环境配置（macOS、Win）</h2><ol>
<li>官网下载 flutter SDK<br>macOS <a href="https://storage.flutter-io.cn/flutter_infra_release/releases/stable/macos/flutter_macos_2.2.3-stable.zip">https://storage.flutter-io.cn/flutter_infra_release/releases/stable/macos/flutter_macos_2.2.3-stable.zip</a><br>Windows <a href="https://storage.flutter-io.cn/flutter_infra_release/releases/stable/windows/flutter_windows_2.2.3-stable.zip">https://storage.flutter-io.cn/flutter_infra_release/releases/stable/windows/flutter_windows_2.2.3-stable.zip</a><br>下载完成后解压缩到某个目录，我一般都放到 ~&#x2F;Documents&#x2F;Flutter 中（macOS）</li>
<li>添加 PATH 环境变量，打开终端配置文件，我用的是 zsh，所以我的配置文件是 ~&#x2F;.zshrc，如果你用的是bash，那么配置文件就是 ~&#x2F;.bash_profile<br>添加如下内容<br>export PATH&#x3D;“$PATH:pwd&#x2F;flutter&#x2F;bin”<br>其中 pwd 就是你存放 flutter SDK 的路径，例如我这里就是 ~&#x2F;Documents&#x2F;Flutter，接着保存并重新打开终端以使配置文件生效。</li>
<li>IDE配置（Android Studio、VSCode）</li>
</ol>
<h2 id="flutter-基本概念"><a href="#flutter-基本概念" class="headerlink" title="flutter 基本概念"></a>flutter 基本概念</h2><ol start="2">
<li>工程结构（yaml文件格式、Image的导入等）</li>
<li>First App（flutter create）</li>
<li>Basic Widget（Container，Row，Column 等）</li>
<li>基本交互（GestureDetector 等）</li>
<li>Splash Screen<br>作业：基本型计算器，支持加减乘除整数及小数运算</li>
</ol>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>1、隐式动画（AnimationContainer）<br>2、显示动画（AnimationController）<br>3、Tween<br>4、Curve<br>5、Timer<br>作业：一个 Demo，屏幕上有一条固定长度且按一定时间间隔前进的小蛇，提供一个方向键来控制小蛇前进的方向</p>
<h2 id="flutter-混合开发"><a href="#flutter-混合开发" class="headerlink" title="flutter 混合开发"></a>flutter 混合开发</h2><p>1、在 Flutter 中使用iOS、Android 原生代码<br>2、插件的编写与集成<br>3、Platform View 的使用方式<br>作业：一个 Demo，用户可以通过点击按钮（Flutter）调用原生方法来获取当前手机的重力加速度值，同时将它们显示在屏幕上（Platform View）</p>
<h2 id="flutter-画板"><a href="#flutter-画板" class="headerlink" title="flutter 画板"></a>flutter 画板</h2><p>1、CustomPainter<br>2、ImageProvider 的原理<br>3、Image 数据处理（RBG的读取与修改）<br>作业：一个简单图片处理（滤镜） Demo，效果不定，自己发挥</p>
<h2 id="公共算法"><a href="#公共算法" class="headerlink" title="公共算法"></a>公共算法</h2><p>1、碰撞检测算法<br>2、小球的贴图滚动效果的实现（我还要研究下，如果可以，就做模拟滚动的效果，否则就是一个小球图片平移）<br>最终作业：一个《重力小球》游戏，用户通过倾斜手机来控制小球的滚动，屏幕中会设置许多陷阱，小球碰到陷阱便会失败，小球顺利滚动到目标地点即成功</p>
]]></content>
  </entry>
  <entry>
    <title>面部特征识别</title>
    <url>/2022/10/09/%E9%9D%A2%E9%83%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>通过 CIDetector 只需要几行代码就可以实现面部特征识别功能<br><img src="/2022/10/09/%E9%9D%A2%E9%83%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/1.jpg"><br><img src="/2022/10/09/%E9%9D%A2%E9%83%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/2.jpg"></p>
<p>目前尝试了下，即使是多个面孔，也能够准确的识别出来<br><img src="/2022/10/09/%E9%9D%A2%E9%83%A8%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/3.jpg"></p>
<p>代码如下</p>
<pre><code class="swift">import UIKit
import QMUIKit

let kScreenWidth = UIScreen.main.bounds.size.width
let kScreenHeight = UIScreen.main.bounds.size.height

final class ViewController: UIViewController &#123;
    var imageView: UIImageView = UIImageView()
    
    override func viewDidLoad() &#123;
        super.viewDidLoad()
            
        let oneFace = UIImage(named: &quot;6&quot;)!
        
        view.addSubview(imageView)
        imageView.frame = .init(origin: .init(x: 0, y: (kScreenHeight - kScreenWidth) / 2), size: .init(width: kScreenWidth, height: kScreenWidth / (oneFace.size.width / oneFace.size.height)))
        imageView.image = oneFace
        imageView.contentMode = .scaleToFill
        
        let detector = CIDetector(ofType: CIDetectorTypeFace, context: CIContext())!
        let ciImage = CIImage(image: oneFace)!
        print(ciImage.extent.size)
        let features = detector.features(in: ciImage)
        print(features)
        for feature in features &#123;
            let face = feature as! CIFaceFeature
            
            var red: UIView
            red = UIView(frame: .init(origin: .zero, size: .init(width: 16, height: 16)))
            red.backgroundColor = .clear
            red.layer.borderWidth = 2
            red.layer.borderColor = UIColor.systemYellow.cgColor
            red.center = .init(
                x: face.leftEyePosition.x / oneFace.size.width * imageView.frame.width,
                y: (1 - face.leftEyePosition.y / oneFace.size.height) * imageView.frame.height
            )
            imageView.addSubview(red)
            
            red = UIView(frame: .init(origin: .zero, size: .init(width: 16, height: 16)))
            red.backgroundColor = .clear
            red.layer.borderWidth = 2
            red.layer.borderColor = UIColor.systemYellow.cgColor
            red.center = .init(
                x: face.rightEyePosition.x / oneFace.size.width * imageView.frame.width,
                y: (1 - face.rightEyePosition.y / oneFace.size.height) * imageView.frame.height
            )
            imageView.addSubview(red)

            red = UIView(frame: .init(origin: .zero, size: .init(width: 16, height: 16)))
            red.backgroundColor = .clear
            red.layer.borderWidth = 2
            red.layer.borderColor = UIColor.systemYellow.cgColor
            red.center = .init(
                x: face.mouthPosition.x / oneFace.size.width * imageView.frame.width,
                y: (1 - face.mouthPosition.y / oneFace.size.height) * imageView.frame.height
            )
            imageView.addSubview(red)

            red = UIView()
            red.backgroundColor = .clear
            red.layer.borderWidth = 2
            red.layer.borderColor = UIColor.systemYellow.cgColor
            red.frame = .init(
                origin: .init(x: face.bounds.origin.x / oneFace.size.width * imageView.frame.width,
                              y: (1 - face.bounds.maxY / oneFace.size.height) * imageView.frame.height),
                size: .init(
                    width: face.bounds.size.width / oneFace.size.width * imageView.frame.width,
                    height: face.bounds.size.height / oneFace.size.height * imageView.frame.height)
            )
            imageView.addSubview(red)
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
  </entry>
</search>
